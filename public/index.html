<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ספרייה - קטלוג בסיסי</title>
    <style>
      body { font-family: system-ui, Arial; margin: 16px; }
      .row { margin-top: 10px; }
      .muted { color: #666; font-size: 13px; }
      input { width: 100%; padding: 10px; font-size: 16px; }
      button { padding: 10px 12px; font-size: 14px; margin: 6px 6px 6px 0; }
      .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
      .card { border: 1px solid #ddd; border-radius: 10px; padding: 10px; cursor: pointer; }
      .title { font-weight: 700; }
      .meta { margin-top: 6px; color: #444; font-size: 14px; }
      .path { margin-top: 6px; color: #888; font-size: 12px; direction: ltr; text-align: left; word-break: break-all; }
      iframe { width: 100%; height: 70vh; border: 1px solid #ddd; border-radius: 10px; margin-top: 12px; }
      a { word-break: break-all; }
      .toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .pill { padding: 4px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color: #444; }
    </style>
  </head>
  <body>
    <h2>קטלוג בסיסי — הקבצים נשארים ב־GitHub</h2>
    <div class="muted">
      טוען מטא־דאטה (<code>/api/metadata</code>) ואם צריך גם מניפסט (<code>/api/manifest</code>),
      מחלץ רשימה גם כשה־JSON הוא Object ולא Array, ובונה נתיב פתיחה אמיתי דרך <code>/lib/...</code>.
    </div>

    <div class="row toolbar">
      <button id="btnLoad" onclick="loadCatalog()">טען קטלוג</button>
      <button onclick="openPath()">פתח נתיב ידני</button>
      <button onclick="ping()">בדיקה: /api/ping</button>
      <span id="status" class="pill">לא נטען</span>
    </div>

    <div class="row">
      <input id="q" placeholder="חיפוש (כותרת/מחבר/נתיב)..." oninput="onSearchInput()" />
    </div>

    <div class="row">
      <input id="path" placeholder="נתיב ידני בתוך הריפו (למשל: אוצריא/ספרים/xxx.pdf)" />
      <div class="muted">
        קישור נוכחי: <a id="link" href="#" target="_blank" rel="noreferrer">—</a>
      </div>
    </div>

    <iframe id="viewer" title="viewer"></iframe>

    <h3 style="margin-top:16px;">תוצאות</h3>
    <div id="results" class="grid"></div>

    <script>
      let rawMetaItems = []
      let items = []
      let currentList = []
      let renderCursor = 0
      const PAGE_SIZE = 60

      function setStatus(text) {
        document.getElementById("status").textContent = text
      }

      function encodePath(path) {
        return String(path)
          .split("/")
          .filter(Boolean)
          .map(encodeURIComponent)
          .join("/")
      }

      function libUrl(pathOrUrl) {
        const v = String(pathOrUrl || "").trim()
        if (!v) return ""
        if (v.startsWith("http://") || v.startsWith("https://")) return v
        return "/lib/" + encodePath(v)
      }

      function refreshLink(url) {
        const a = document.getElementById("link")
        a.textContent = url || "—"
        a.href = url || "#"
      }

      function openPath() {
        const p = document.getElementById("path").value.trim()
        const url = libUrl(p)
        if (!url) return
        refreshLink(url)
        document.getElementById("viewer").src = url
      }

      function openItem(it) {
        document.getElementById("path").value = it.path || ""
        const url = libUrl(it.path)
        refreshLink(url)
        document.getElementById("viewer").src = url
        window.scrollTo({ top: 0, behavior: "smooth" })
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;")
      }

      // ---- זיהויים "חכמים" (כי מבנה ה־JSON לא תמיד אחיד)

      function looksLikePath(s) {
        const x = String(s || "")
        if (!x) return false
        if (x.includes("://")) return true
        if (x.includes("/") || x.includes("\\")) return true
        if (/\.(pdf|txt|docx)$/i.test(x)) return true
        return false
      }

      function looksLikeHash(s) {
        const x = String(s || "").trim()
        if (!x) return false
        // sha1 (40), md5 (32), או דומה
        if (/^[0-9a-f]{40}$/i.test(x)) return true
        if (/^[0-9a-f]{32}$/i.test(x)) return true
        return false
      }

      function objectToArrayMap(obj) {
        const arr = []
        for (const [k, v] of Object.entries(obj || {})) {
          if (v && typeof v === "object") {
            // שומרים את המפתח (יכול להיות hash או path)
            arr.push({ ...v, _key: k })
          } else {
            arr.push({ title: String(v ?? "").trim(), _key: k })
          }
        }
        return arr
      }

      function extractBestCollection(json) {
        // מחזיר Array של פריטים (גם אם המקור היה Object), בצורה הכי סבירה.

        if (Array.isArray(json)) return json
        if (!json || typeof json !== "object") return []

        // 1) אם יש מערכים ברמה העליונה – בחר הגדול ביותר
        let bestArr = null
        let bestLen = -1
        for (const v of Object.values(json)) {
          if (Array.isArray(v) && v.length > bestLen) {
            bestArr = v
            bestLen = v.length
          }
        }
        if (bestArr) return bestArr

        // 2) מפתחות נפוצים
        const containerKeys = ["items", "books", "data", "metadata", "list"]
        for (const k of containerKeys) {
          const v = json[k]
          if (Array.isArray(v)) return v
          if (v && typeof v === "object") return objectToArrayMap(v)
        }

        // 3) אם זה Object ענק שמפתחותיו נראים כמו נתיבים/האשים – הפוך למערך
        const keys = Object.keys(json)
        if (keys.length) {
          const sampleN = Math.min(keys.length, 500)
          let pathy = 0
          let hashy = 0
          for (let i = 0; i < sampleN; i++) {
            const kk = keys[i]
            if (looksLikePath(kk)) pathy++
            if (looksLikeHash(kk)) hashy++
          }
          const ratio = (pathy + hashy) / sampleN
          if (ratio >= 0.15) return objectToArrayMap(json)
        }

        // 4) חיפוש רמה אחת פנימה: אם יש Object פנימי ענק – קח אותו
        let bestObj = null
        let bestObjSize = 0
        for (const v of Object.values(json)) {
          if (v && typeof v === "object" && !Array.isArray(v)) {
            const size = Object.keys(v).length
            if (size > bestObjSize) {
              bestObjSize = size
              bestObj = v
            }
          }
        }
        if (bestObj && bestObjSize > 0) return objectToArrayMap(bestObj)

        return []
      }

      function normalizeMetaItem(x) {
        const o = (x && typeof x === "object") ? x : {}

        const titleVal =
          o.title ?? o.name ?? o.he_title ?? o.heb_title ?? o.book ?? o.display ?? ""

        const authorVal =
          o.author ?? o.authors ?? o.by ?? o.creator ?? o.writer ?? ""

        // לפעמים הנתיב לא נמצא בפריט אלא במפתח (_key)
        const pathVal =
          o.path ?? o.file ?? o.filename ?? o.relpath ?? o.uri ?? o.url ?? ""

        // לפעמים יש id/hash
        const idVal =
          o.id ?? o.hash ?? o.sha ?? o.sha1 ?? o.md5 ?? o.filehash ?? o._key ?? ""

        const title = Array.isArray(titleVal) ? titleVal.join(" ") : titleVal
        const author = Array.isArray(authorVal) ? authorVal.join(", ") : authorVal
        const path = Array.isArray(pathVal) ? pathVal[0] : pathVal

        return {
          title: String(title || "").trim(),
          author: String(author || "").trim(),
          path: String(path || "").trim(),
          id: String(idVal || "").trim(),
          _key: String(o._key || "").trim()
        }
      }

      function tryPickHashFromMeta(meta) {
        // סדר עדיפויות: id אם נראה כמו hash, אחרת _key אם נראה כמו hash
        if (looksLikeHash(meta.id)) return meta.id
        if (looksLikeHash(meta._key)) return meta._key
        // לפעמים מאחסנים hash בתוך "path" (לא באמת path)
        if (looksLikeHash(meta.path)) return meta.path
        return ""
      }

      function pickPathFromMeta(meta) {
        // אם יש path אמיתי – מעולה
        if (looksLikePath(meta.path)) return meta.path
        // לפעמים המפתח הוא path
        if (looksLikePath(meta._key)) return meta._key
        return ""
      }

      async function buildHashToPathMap(manifestJson, onProgress) {
        // מניפסט צפוי להיות Object: { "path/to/file": "hash" } או { "path": {hash:"..."} }
        // נבנה Map: hash -> path (הראשון שנמצא).
        const map = new Map()

        let entries = null
        if (manifestJson && typeof manifestJson === "object") {
          // אם יש wrapper
          const v = manifestJson.files || manifestJson.manifest || manifestJson.data || manifestJson
          if (v && typeof v === "object" && !Array.isArray(v)) {
            entries = Object.entries(v)
          }
        }

        if (!entries) return map

        const total = entries.length
        for (let i = 0; i < total; i++) {
          const [p, val] = entries[i]
          let h = ""

          if (typeof val === "string") {
            h = val
          } else if (val && typeof val === "object") {
            h = val.hash || val.sha || val.sha1 || val.md5 || ""
          }

          if (h && !map.has(h)) {
            map.set(String(h), String(p))
          }

          if (i % 5000 === 0) {
            if (onProgress) onProgress(i, total)
            await new Promise(r => setTimeout(r, 0))
          }
        }

        if (onProgress) onProgress(total, total)
        return map
      }

      async function buildIndex(list, onProgress) {
        const out = []
        const total = list.length

        for (let i = 0; i < total; i++) {
          const it = list[i]
          if (it.path) {
            const q = (it.title + " " + it.author + " " + it.path).toLowerCase()
            out.push({ ...it, q })
          } else {
            const q = (it.title + " " + it.author + " " + it.id + " " + it._key).toLowerCase()
            out.push({ ...it, q })
          }

          if (i % 2000 === 0) {
            if (onProgress) onProgress(i, total)
            await new Promise(r => setTimeout(r, 0))
          }
        }

        if (onProgress) onProgress(total, total)
        return out
      }

      function clearResults() {
        document.getElementById("results").innerHTML = ""
        renderCursor = 0
      }

      function renderNextPage() {
        const root = document.getElementById("results")
        const end = Math.min(renderCursor + PAGE_SIZE, currentList.length)

        for (let i = renderCursor; i < end; i++) {
          const it = currentList[i]
          const div = document.createElement("div")
          div.className = "card"
          div.innerHTML = `
            <div class="title">${escapeHtml(it.title || "(ללא כותרת)")}</div>
            <div class="meta">${escapeHtml(it.author || "")}</div>
            <div class="path">${escapeHtml(it.path || "(אין נתיב)")} </div>
          `
          div.onclick = () => openItem(it)
          root.appendChild(div)
        }

        renderCursor = end
      }

      function applySearch() {
        const q = document.getElementById("q").value.trim().toLowerCase()

        if (!q) {
          currentList = items
        } else {
          currentList = items.filter(it => it.q.includes(q))
        }

        clearResults()
        renderNextPage()
        setStatus(`תוצאות: ${currentList.length} (נטען: ${items.length})`)
      }

      let searchTimer = null
      function onSearchInput() {
        clearTimeout(searchTimer)
        searchTimer = setTimeout(applySearch, 150)
      }

      async function loadCatalog() {
        setStatus("טוען metadata...")
        document.getElementById("btnLoad").disabled = true

        try {
          // 1) metadata
          const rMeta = await fetch("/api/metadata", { cache: "no-store" })
          if (!rMeta.ok) throw new Error(`metadata HTTP ${rMeta.status}`)
          const metaJson = await rMeta.json()

          rawMetaItems = extractBestCollection(metaJson)
          if (!rawMetaItems.length) {
            console.log("metadata json (raw):", metaJson)
            setStatus("נטען metadata אבל לא הצלחתי לחלץ רשימה")
            alert("נטען metadata.json אבל לא זוהתה בו רשימת ספרים. בדוק בקונסול (F12) את המבנה שמודפס.")
            return
          }

          // 2) נרמול בסיסי
          setStatus(`מעבד metadata... (0/${rawMetaItems.length})`)
          let normalized = []
          for (let i = 0; i < rawMetaItems.length; i++) {
            normalized.push(normalizeMetaItem(rawMetaItems[i]))
            if (i % 3000 === 0) {
              setStatus(`מעבד metadata... (${i}/${rawMetaItems.length})`)
              await new Promise(r => setTimeout(r, 0))
            }
          }
          setStatus(`מעבד metadata... (${rawMetaItems.length}/${rawMetaItems.length})`)

          // 3) האם חסרים נתיבים? אם כן, נטען מניפסט ונשלים.
          let missingPathCount = 0
          for (let i = 0; i < Math.min(normalized.length, 2000); i++) {
            const p = pickPathFromMeta(normalized[i])
            if (!p) missingPathCount++
          }

          const needManifest = missingPathCount > 0
          let hashToPath = null

          if (needManifest) {
            setStatus("טוען manifest (למציאת נתיבים אמיתיים)...")
            const rMan = await fetch("/api/manifest", { cache: "no-store" })
            if (!rMan.ok) throw new Error(`manifest HTTP ${rMan.status}`)
            const manifestJson = await rMan.json()

            setStatus("בונה מפת hash→path... (0/?)")
            hashToPath = await buildHashToPathMap(manifestJson, (done, total) => {
              setStatus(`בונה מפת hash→path... (${done}/${total})`)
            })
          }

          // 4) השלמת path
          setStatus(`משלים נתיבים... (0/${normalized.length})`)
          for (let i = 0; i < normalized.length; i++) {
            let p = pickPathFromMeta(normalized[i])

            if (!p && hashToPath) {
              const h = tryPickHashFromMeta(normalized[i])
              if (h && hashToPath.has(h)) p = hashToPath.get(h)
            }

            normalized[i].path = String(p || "").trim()

            if (i % 5000 === 0) {
              setStatus(`משלים נתיבים... (${i}/${normalized.length})`)
              await new Promise(r => setTimeout(r, 0))
            }
          }
          setStatus(`משלים נתיבים... (${normalized.length}/${normalized.length})`)

          // 5) אינדוקס + UI
          setStatus(`בונה אינדקס חיפוש... (0/${normalized.length})`)
          items = await buildIndex(normalized, (done, total) => {
            setStatus(`בונה אינדקס חיפוש... (${done}/${total})`)
          })

          // מסנן פריטים בלי path (כי אי אפשר לפתוח אותם)
          const before = items.length
          items = items.filter(it => it.path && looksLikePath(it.path))
          const after = items.length

          currentList = items
          clearResults()
          renderNextPage()

          setStatus(`נטען: ${after} (סוננו: ${before - after})`)

          window.onscroll = () => {
            if (renderCursor >= currentList.length) return
            const nearBottom =
              (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 400)
            if (nearBottom) renderNextPage()
          }
        } catch (e) {
          console.error(e)
          setStatus("שגיאה")
          alert("שגיאה: " + (e && e.message ? e.message : e))
        } finally {
          document.getElementById("btnLoad").disabled = false
        }
      }

      async function ping() {
        const r = await fetch("/api/ping")
        alert(await r.text())
      }
    </script>
  </body>
</html>
