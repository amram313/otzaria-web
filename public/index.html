<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>קטלוג ספרייה</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Arial; margin: 18px; }
      .muted { color: #666; font-size: 13px; }
      .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .pill { border: 1px solid #ddd; border-radius: 999px; padding: 6px 10px; display: inline-flex; gap: 8px; align-items: center; }
      input[type="text"] { padding: 8px 10px; border: 1px solid #ddd; border-radius: 8px; width: min(520px, 92vw); }
      button { padding: 8px 10px; border: 1px solid #ddd; border-radius: 8px; background: #fff; cursor: pointer; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      .layout { display: grid; grid-template-columns: 320px 1fr; gap: 16px; align-items: start; }
      @media (max-width: 900px) { .layout { grid-template-columns: 1fr; } }
      .panel { border: 1px solid #eee; border-radius: 12px; padding: 12px; }
      .tree { font-size: 14px; line-height: 1.5; }
      .node { display: block; padding: 3px 0; }
      .node button { border: none; padding: 0; background: transparent; cursor: pointer; text-align: right; }
      .node .count { color: #888; font-size: 12px; margin-right: 6px; }
      .node .toggle { width: 18px; display: inline-block; color: #888; }
      .node .label.sel { font-weight: 700; text-decoration: underline; }
      .node .label { cursor: pointer; }
      .indent { margin-right: 18px; border-right: 1px dashed #eee; padding-right: 10px; }
      .cards { margin-top: 12px; }
      .card { border: 1px solid #eee; border-radius: 12px; padding: 10px 12px; margin-bottom: 10px; }
      .title { font-weight: 700; }
      .meta { color: #555; font-size: 13px; margin-top: 2px; }
      .path { color: #888; font-size: 12px; margin-top: 6px; word-break: break-word; }
      .actions { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
      .status { margin-top: 10px; font-size: 13px; color: #444; white-space: pre-wrap; }
    </style>
  </head>
  <body>
    <h2>קטלוג — קטגוריות + חיפוש על כל המאגר</h2>
    <div class="muted">
      מקור הנתונים (ברירת מחדל): <b>Y-PLONI/otzaria-library</b> על <b>main</b>. אם החלפת מקור בעבר, אין צורך לנקות ידנית — המפתח במטמון תלוי במקור.
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="btnRefresh" onclick="loadCatalog(true)">כפה רענון</button>
      <button onclick="scrollToResults()">לתוצאות</button>
      <label class="pill">
        <span>מצב</span>
        <select id="mode" onchange="applyFilters()" style="border:none; background:transparent;">
          <option value="with">רק עם קובץ</option>
          <option value="all">הכל</option>
          <option value="without">רק בלי קובץ</option>
        </select>
      </label>
      <label class="pill">
        <span>חיפוש</span>
        <input id="q" type="text" placeholder="חפש בכותרת / מחבר / נתיב..." oninput="debouncedApply()" />
      </label>
    </div>

    <div class="layout" style="margin-top:12px;">
      <div class="panel">
        <div class="row" style="justify-content: space-between;">
          <div><b>קטגוריות</b></div>
          <button onclick="clearCategory()">נקה</button>
        </div>
        <div class="muted" style="margin-top:6px;">
          הקטגוריות נגזרות מהנתיב של הקובץ, אבל <b>מדלגות על תיקיות מקור</b> (כמו sefariaToOtzaria/sefaria_export/ספרים/אוצריא/...) כדי שתראה קטגוריות “אמיתיות” (למשל תלמוד בבלי → סדר מועד...).
        </div>
        <div id="tree" class="tree" style="margin-top:10px;"></div>
      </div>

      <div class="panel">
        <div id="resultsTitle"><b>תוצאות</b></div>
        <div class="muted" id="counts" style="margin-top:6px;"></div>
        <div id="cards" class="cards"></div>
        <div id="status" class="status"></div>
      </div>
    </div>

    <script>
      // ---------------------------
      // Minimal IndexedDB cache
      // ---------------------------
      const UPSTREAM_ID = "Y-PLONI/otzaria-library@main"
      const CACHE_KEY = "catalog:" + UPSTREAM_ID + ":v4"
      const DB_NAME = "otzaria_catalog_db"
      const STORE = "cache"

      function openDb() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1)
          req.onupgradeneeded = () => {
            const db = req.result
            if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE)
          }
          req.onsuccess = () => resolve(req.result)
          req.onerror = () => reject(req.error)
        })
      }

      async function idbGet(key) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readonly")
          const st = tx.objectStore(STORE)
          const req = st.get(key)
          req.onsuccess = () => resolve(req.result || null)
          req.onerror = () => reject(req.error)
        })
      }

      async function idbSet(key, value) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readwrite")
          const st = tx.objectStore(STORE)
          const req = st.put(value, key)
          req.onsuccess = () => resolve(true)
          req.onerror = () => reject(req.error)
        })
      }

      // ---------------------------
      // Helpers
      // ---------------------------
      function tick() { return new Promise(r => setTimeout(r, 0)) }

      function setStatus(s) {
        document.getElementById("status").textContent = s || ""
      }

      async function fetchJsonAny(urls) {
        let lastErr = null
        for (const u of urls) {
          try {
            const r = await fetch(u, { cache: "no-store" })
            if (r.ok) return await r.json()
            lastErr = new Error(`${u} -> HTTP ${r.status}`)
          } catch (e) {
            lastErr = e
          }
        }
        throw lastErr || new Error("fetch failed")
      }

      function objectToArrayMap(obj) {
        const out = []
        for (const [k,v] of Object.entries(obj)) {
          if (v && typeof v === "object") out.push({ ...v, key: k })
          else out.push({ key: k, value: v })
        }
        return out
      }

      function extractBestCollection(json) {
        if (!json) return []
        if (Array.isArray(json)) return json

        // If object contains any big arrays, prefer the largest
        let bestArr = null
        let bestLen = 0
        for (const v of Object.values(json)) {
          if (Array.isArray(v) && v.length > bestLen) {
            bestArr = v
            bestLen = v.length
          }
        }
        if (bestArr) return bestArr

        const containerKeys = ["items", "books", "data", "metadata", "list"]
        for (const k of containerKeys) {
          const v = json[k]
          if (Array.isArray(v)) return v
          if (v && typeof v === "object") return objectToArrayMap(v)
        }

        // last resort: object-to-array
        if (typeof json === "object") return objectToArrayMap(json)
        return []
      }

      function deepCollectStrings(obj, maxDepth = 5, maxLen = 220, depth = 0, out = []) {
        if (obj == null) return out
        if (depth > maxDepth) return out
        if (typeof obj === "string") {
          const s = obj.trim()
          if (s && s.length <= maxLen) out.push(s)
          return out
        }
        if (typeof obj === "number" || typeof obj === "boolean") {
          out.push(String(obj))
          return out
        }
        if (Array.isArray(obj)) {
          for (const v of obj) deepCollectStrings(v, maxDepth, maxLen, depth + 1, out)
          return out
        }
        if (typeof obj === "object") {
          for (const [k,v] of Object.entries(obj)) {
            if (typeof k === "string") {
              const kk = k.trim()
              if (kk && kk.length <= maxLen) out.push(kk)
            }
            deepCollectStrings(v, maxDepth, maxLen, depth + 1, out)
          }
        }
        return out
      }

      function looksLikeHashish(s) {
        const x = String(s || "").trim()
        if (!x) return false
        // sha1/sha256/hex
        if (/^(sha1|sha256|md5)[:\s]/i.test(x)) return true
        if (/^[a-f0-9]{32}$/i.test(x)) return true
        if (/^[a-f0-9]{40}$/i.test(x)) return true
        if (/^[a-f0-9]{64}$/i.test(x)) return true
        return false
      }

      function normHashish(s) {
        const x = String(s || "").trim().toLowerCase()
        if (!x) return ""
        return x.replace(/^(sha1|sha256|md5)[:\s]+/i, "")
      }

      function looksLikePath(s) {
        const x = String(s || "").trim()
        if (!x) return false
        if (x.includes("://")) return true
        if ((x.includes("/") || x.includes("\\")) && /\.[a-z0-9]{2,6}$/i.test(x)) return true
        if (/\.(pdf|txt|docx|json|zip|md)$/i.test(x)) return true
        return false
      }

      function basenameOf(p) {
        const x = String(p || "").trim()
        if (!x) return ""
        const s = x.replaceAll("\\", "/")
        const parts = s.split("/")
        return (parts[parts.length - 1] || "").trim()
      }

      function stemOfFilename(fn) {
        const x = String(fn || "").trim()
        if (!x) return ""
        return x.replace(/\.[a-z0-9]{2,6}$/i, "")
      }

      function extractManifestEntries(manifestJson) {
        if (!manifestJson || typeof manifestJson !== "object") return []
        const v = manifestJson.files || manifestJson.manifest || manifestJson.data || manifestJson
        if (!v || typeof v !== "object" || Array.isArray(v)) return []
        return Object.entries(v)
      }

      function collectStringsFromValue(v, max = 24) {
        const out = []
        const push = (s) => {
          const x = String(s || "").trim()
          if (!x) return
          if (x.length > 280) return
          out.push(x)
        }
        if (v == null) return out
        if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
          push(v)
          return out
        }
        if (Array.isArray(v)) {
          for (const it of v) {
            if (out.length >= max) break
            if (typeof it === "string" || typeof it === "number" || typeof it === "boolean") push(it)
            else if (it && typeof it === "object") {
              for (const vv of Object.values(it)) {
                if (out.length >= max) break
                if (typeof vv === "string" || typeof vv === "number" || typeof vv === "boolean") push(vv)
              }
            }
          }
          return out
        }
        if (typeof v === "object") {
          for (const [k,vv] of Object.entries(v)) {
            if (out.length >= max) break
            push(k)
            if (typeof vv === "string" || typeof vv === "number" || typeof vv === "boolean") push(vv)
          }
        }
        return out
      }

      async function buildManifestMaps(manifestJson, onProgress) {
        const hashToPath = new Map()
        const baseToPath = new Map()
        const stemToPath = new Map()
        const entries = extractManifestEntries(manifestJson)
        const total = entries.length

        for (let i = 0; i < total; i++) {
          const [k, vRaw] = entries[i]
          const kStr = String(k || "").trim()
          const vStrings = collectStringsFromValue(vRaw)

          let path = ""
          if (looksLikePath(kStr)) path = kStr
          else {
            for (const s of vStrings) {
              if (looksLikePath(s)) { path = s; break }
            }
          }

          if (path) {
            const b = basenameOf(path).toLowerCase()
            const st = stemOfFilename(b).toLowerCase()
            if (b && !baseToPath.has(b)) baseToPath.set(b, path)
            if (st && !stemToPath.has(st)) stemToPath.set(st, path)

            if (looksLikeHashish(kStr)) {
              const hk = normHashish(kStr)
              if (hk && !hashToPath.has(hk)) hashToPath.set(hk, path)
            }
            for (const s of vStrings) {
              if (looksLikeHashish(s)) {
                const hv = normHashish(s)
                if (hv && !hashToPath.has(hv)) hashToPath.set(hv, path)
              }
              const bb = basenameOf(s).toLowerCase()
              const sst = stemOfFilename(bb).toLowerCase()
              if (bb && !baseToPath.has(bb)) baseToPath.set(bb, path)
              if (sst && !stemToPath.has(sst)) stemToPath.set(sst, path)
            }
          }

          if (i % 5000 === 0) {
            if (onProgress) onProgress(i, total)
            await tick()
          }
        }

        if (onProgress) onProgress(total, total)
        return { hashToPath, baseToPath, stemToPath }
      }

      function resolvePathForMeta(meta, maps) {
        if (looksLikePath(meta.path)) return meta.path

        const strings = deepCollectStrings(meta._raw, 6, 240)

        for (const s of strings) {
          if (!looksLikeHashish(s)) continue
          const h = normHashish(s)
          if (h && maps.hashToPath.has(h)) return maps.hashToPath.get(h)
        }

        for (const s of strings) {
          const b = basenameOf(s).toLowerCase()
          if (b && maps.baseToPath.has(b)) return maps.baseToPath.get(b)
          const st = stemOfFilename(b).toLowerCase()
          if (st && maps.stemToPath.has(st)) return maps.stemToPath.get(st)
        }

        return ""
      }

      function normalizeMetaItem(raw) {
        const title = (raw && (raw.title || raw.name || raw.heTitle || raw.he_name)) ? String(raw.title || raw.name || raw.heTitle || raw.he_name).trim() : ""
        const author = (raw && (raw.author || raw.by || raw.creator || raw.heAuthor)) ? String(raw.author || raw.by || raw.creator || raw.heAuthor).trim() : ""
        return {
          title,
          author,
          path: "",
          _raw: raw
        }
      }

      // ---------------------------
      // Categories
      // ---------------------------
      function safeDecodeURIComponent(s) {
        try { return decodeURIComponent(s) } catch (_) { return s }
      }

      function splitPathSegments(p) {
        return String(p || "").split("/").filter(Boolean).map(safeDecodeURIComponent)
      }

      function categorySegmentsForPath(path) {
        if (!path) return ["(ללא קובץ)"]
        const segs = splitPathSegments(path)
        if (segs.length < 2) return ["(ללא קטגוריה)"]

        // Remove filename
        const dirSegs = segs.slice(0, -1)

        // Prefer to start after "ספרים/אוצריא" if exists (matches the upstream example).
        let start = 0
        const idxBooks = dirSegs.indexOf("ספרים")
        if (idxBooks >= 0) {
          start = idxBooks + 1
          if (dirSegs[start] === "אוצריא") start += 1
        } else {
          // fallback: after sefaria_export (if present)
          const idxSef = dirSegs.indexOf("sefaria_export")
          if (idxSef >= 0) start = idxSef + 1
        }

        const cats = dirSegs.slice(start)
        return cats.length ? cats : ["(ללא קטגוריה)"]
      }

      function buildTree(items) {
        const root = { name: "הכל", path: [], count: 0, children: new Map(), open: true }
        for (const it of items) {
          const segs = it._cats || ["(ללא קטגוריה)"]
          root.count++
          let node = root
          for (const s of segs) {
            if (!node.children.has(s)) {
              node.children.set(s, { name: s, path: node.path.concat([s]), count: 0, children: new Map(), open: false })
            }
            node = node.children.get(s)
            node.count++
          }
        }
        return root
      }

      function treeToArray(node) {
        // stable order: by count desc, then name
        const arr = Array.from(node.children.values())
        arr.sort((a,b) => (b.count - a.count) || a.name.localeCompare(b.name, "he"))
        return arr
      }

      // ---------------------------
      // UI state
      // ---------------------------
      let items = []
      let currentList = []
      let renderCursor = 0
      const PAGE_SIZE = 120

      let selectedCatPath = []  // array of segments
      let treeRoot = null

      function isPrefix(prefix, full) {
        if (!prefix || !prefix.length) return true
        if (!full || full.length < prefix.length) return false
        for (let i=0;i<prefix.length;i++) {
          if (full[i] !== prefix[i]) return false
        }
        return true
      }

      function clearCategory() {
        selectedCatPath = []
        renderTree()
        applyFilters()
      }

      function scrollToResults() {
        document.getElementById("resultsTitle").scrollIntoView({ behavior: "smooth" })
      }

      function clearResults() {
        document.getElementById("cards").innerHTML = ""
        renderCursor = 0
      }

      function renderNextPage() {
        const cards = document.getElementById("cards")
        const end = Math.min(currentList.length, renderCursor + PAGE_SIZE)
        for (let i = renderCursor; i < end; i++) {
          const it = currentList[i]
          const card = document.createElement("div")
          card.className = "card"

          const t = document.createElement("div")
          t.className = "title"
          t.textContent = it.title || "(ללא כותרת)"

          const m = document.createElement("div")
          m.className = "meta"
          m.textContent = it.author || ""

          const p = document.createElement("div")
          p.className = "path"
          p.textContent = it.path || "(אין נתיב)"

          const actions = document.createElement("div")
          actions.className = "actions"

          const btnOpen = document.createElement("button")
          btnOpen.textContent = "פתח בטאב"
          btnOpen.disabled = !it.path
          btnOpen.onclick = () => {
            const u = "/view/?path=" + encodeURIComponent(it.path)
            window.open(u, "_blank", "noopener")
          }

          const btnInline = document.createElement("button")
          btnInline.textContent = "צפה כאן"
          btnInline.disabled = !it.path
          btnInline.onclick = () => {
            window.location.href = "/view/?path=" + encodeURIComponent(it.path)
          }

          actions.appendChild(btnOpen)
          actions.appendChild(btnInline)

          card.appendChild(t)
          card.appendChild(m)
          card.appendChild(p)
          card.appendChild(actions)

          cards.appendChild(card)
        }
        renderCursor = end
      }

      function setCounts() {
        const withPath = items.filter(it => it.path).length
        const withoutPath = items.length - withPath
        const shown = currentList.length
        document.getElementById("counts").textContent =
          `מוצג: ${shown} | סה"כ: ${items.length} | עם קובץ: ${withPath} | בלי קובץ: ${withoutPath}`
      }

      function applyFilters() {
        const q = document.getElementById("q").value.trim().toLowerCase()
        const mode = document.getElementById("mode").value

        let base = items

        if (mode === "with") base = base.filter(it => it.path)
        if (mode === "without") base = base.filter(it => !it.path)

        if (selectedCatPath.length) {
          base = base.filter(it => isPrefix(selectedCatPath, it._cats))
        }

        if (q) {
          base = base.filter(it => it.q.includes(q))
        }

        currentList = base
        clearResults()
        renderNextPage()
        setCounts()
      }

      let timer = null
      function debouncedApply() {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => applyFilters(), 150)
      }

      function renderTree() {
        const container = document.getElementById("tree")
        container.innerHTML = ""
        if (!treeRoot) return

        const renderNode = (node, depth) => {
          const wrap = document.createElement("div")
          wrap.className = "node" + (depth ? " indent" : "")

          const children = treeToArray(node)
          const hasKids = children.length > 0

          const toggle = document.createElement("span")
          toggle.className = "toggle"
          toggle.textContent = hasKids ? (node.open ? "▾" : "▸") : " "

          const label = document.createElement("span")
          label.className = "label" + ((selectedCatPath.join("|") === node.path.join("|")) ? " sel" : "")
          label.textContent = node.name

          const count = document.createElement("span")
          count.className = "count"
          count.textContent = `(${node.count})`

          // Click behavior: label selects category; toggle opens/closes
          toggle.onclick = () => {
            if (!hasKids) return
            node.open = !node.open
            renderTree()
          }
          label.onclick = () => {
            selectedCatPath = node.path.slice()
            // auto-open selected chain
            renderTree()
            applyFilters()
          }

          wrap.appendChild(toggle)
          wrap.appendChild(label)
          wrap.appendChild(count)
          container.appendChild(wrap)

          if (hasKids && node.open) {
            for (const ch of children) renderNode(ch, depth + 1)
          }
        }

        // Root summary entry
        const rootRow = document.createElement("div")
        rootRow.className = "node"
        const rootLabel = document.createElement("span")
        rootLabel.className = "label" + (selectedCatPath.length === 0 ? " sel" : "")
        rootLabel.textContent = "הכל"
        const rootCount = document.createElement("span")
        rootCount.className = "count"
        rootCount.textContent = `(${treeRoot.count})`
        rootLabel.onclick = () => {
          selectedCatPath = []
          renderTree()
          applyFilters()
        }
        rootRow.appendChild(document.createElement("span"))
        rootRow.appendChild(rootLabel)
        rootRow.appendChild(rootCount)
        container.appendChild(rootRow)

        // Children
        treeRoot.open = true
        for (const ch of treeToArray(treeRoot)) renderNode(ch, 1)
      }

      // ---------------------------
      // Load catalog (auto + refresh)
      // ---------------------------
      async function loadCatalog(force = false) {
        document.getElementById("btnRefresh").disabled = true
        setStatus(force ? "טוען מחדש מהמקור..." : "טוען...")

        try {
          if (!force) {
            const cached = await idbGet(CACHE_KEY)
            if (cached && cached.items && Array.isArray(cached.items)) {
              items = cached.items
              treeRoot = buildTree(items)
              renderTree()
              applyFilters()
              setStatus(`נטען מהמטמון | ${new Date(cached.savedAt).toLocaleString("he-IL")}`)
              document.getElementById("btnRefresh").disabled = false
              // Continue in background? (no) — keep deterministic; only refresh on demand.
              return
            }
          }

          setStatus("טוען metadata...")
          const metaJson = await fetchJsonAny(["/api/metadata", "/lib/metadata.json"])
          const rawMetaItems = extractBestCollection(metaJson)
          if (!rawMetaItems.length) {
            throw new Error("נטען metadata אבל לא זוהתה רשימה")
          }

          setStatus("מנרמל metadata...")
          const normalized = rawMetaItems.map(normalizeMetaItem)

          setStatus("טוען files_manifest...")
          const manifestJson = await fetchJsonAny(["/api/manifest", "/lib/files_manifest.json"])

          setStatus("בונה מפות מה־manifest...")
          const maps = await buildManifestMaps(manifestJson, (done, total) => {
            setStatus(`בונה מפות מה־manifest... (${done}/${total})`)
          })

          setStatus(`משלים נתיבים... (0/${normalized.length})`)
          let filled = 0
          for (let i = 0; i < normalized.length; i++) {
            const p = resolvePathForMeta(normalized[i], maps)
            normalized[i].path = looksLikePath(p) ? String(p).trim() : ""
            normalized[i]._cats = categorySegmentsForPath(normalized[i].path)
            if (normalized[i].path) filled++

            if (i % 1000 === 0) {
              setStatus(`משלים נתיבים... (${i}/${normalized.length}) | עם קובץ: ${filled}`)
              await tick()
            }
          }

          setStatus("בונה אינדקס חיפוש...")
          const out = []
          for (let i = 0; i < normalized.length; i++) {
            const it = normalized[i]
            const q = (it.title + " " + it.author + " " + it.path + " " + (it._cats || []).join(" ")).toLowerCase()
            out.push({ ...it, q })
            if (i % 2000 === 0) await tick()
          }

          items = out
          treeRoot = buildTree(items)
          renderTree()
          applyFilters()

          await idbSet(CACHE_KEY, { savedAt: Date.now(), items })
          setStatus(`נטען + נשמר במטמון | סה"כ: ${items.length} | עם קובץ: ${filled}`)
        } catch (e) {
          console.error(e)
          setStatus("שגיאה: " + (e && e.message ? e.message : e))
          alert("שגיאה: " + (e && e.message ? e.message : e))
        } finally {
          document.getElementById("btnRefresh").disabled = false
        }
      }

      // Auto-load on first paint
      loadCatalog(false)

      window.onscroll = () => {
        if (renderCursor >= currentList.length) return
        const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 500)
        if (nearBottom) renderNextPage()
      }
    </script>
  </body>
</html>
