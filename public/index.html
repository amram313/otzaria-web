<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ספרייה - קטלוג</title>
    <style>
      body { font-family: system-ui, Arial; margin: 16px; }
      .row { margin-top: 10px; }
      .muted { color: #666; font-size: 13px; }
      input { width: 100%; padding: 10px; font-size: 16px; }
      button { padding: 10px 12px; font-size: 14px; margin: 6px 6px 6px 0; cursor: pointer; }
      .btnSmall { padding: 6px 10px; font-size: 13px; margin: 0; }
      .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
      .card { border: 1px solid #ddd; border-radius: 10px; padding: 10px; cursor: pointer; }
      .title { font-weight: 700; }
      .meta { margin-top: 6px; color: #444; font-size: 14px; }
      .path { margin-top: 6px; color: #888; font-size: 12px; direction: ltr; text-align: left; word-break: break-all; }
      .toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .pill { padding: 4px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color: #444; }
      .viewerWrap { display: none; margin-top: 12px; }
      iframe { width: 100%; height: 70vh; border: 1px solid #ddd; border-radius: 10px; }
      label { user-select: none; }
      .actions { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
    </style>
  </head>

  <body>
    <h2>קטלוג — פתיחה יציבה</h2>
    <div class="muted">
      קליק על כרטיסייה פותח בטאב חדש (כדי שלא “יקפוץ” בין כרטיסיות). אם תרצה, יש גם “צפה כאן”.
    </div>

    <div class="row toolbar">
      <button id="btnLoad" onclick="loadCatalog()">טען קטלוג</button>
      <button onclick="scrollToResults()">לתוצאות</button>
      <button onclick="openPathInNewTab()">פתח נתיב ידני בטאב</button>
      <button onclick="openPathInline()">צפה בנתיב ידני כאן</button>
      <button onclick="ping()">בדיקה: /api/ping</button>

      <label class="pill">
        <input id="showAll" type="checkbox" onchange="applySearch()" />
        הצג גם פריטים בלי קובץ
      </label>

      <span id="status" class="pill">לא נטען</span>
    </div>

    <div class="row">
      <input id="q" placeholder="חיפוש (כותרת/מחבר/נתיב)..." oninput="onSearchInput()" />
    </div>

    <div class="row">
      <input id="path" placeholder="נתיב ידני בתוך הריפו (למשל: .../file.pdf)" />
      <div class="muted">
        קישור נוכחי: <a id="link" href="#" target="_blank" rel="noreferrer">—</a>
      </div>
    </div>

    <!-- Viewer נמצא למעלה כדי שלא יגרום לגלילה/טעינת עוד כרטיסיות -->
    <div id="viewerWrap" class="viewerWrap">
      <h3 style="margin: 0 0 8px 0;">צפייה בתוך הדף</h3>
      <iframe id="viewer" title="viewer"></iframe>
    </div>

    <h3 id="resultsTitle" style="margin-top:16px;">תוצאות</h3>
    <div id="results" class="grid"></div>

    <script>
      let items = []
      let currentList = []
      let renderCursor = 0
      const PAGE_SIZE = 60

      function setStatus(text) {
        document.getElementById("status").textContent = text
      }

      function tick() {
        return new Promise(r => setTimeout(r, 0))
      }

      function scrollToResults() {
        document.getElementById("resultsTitle").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function showViewer() {
        document.getElementById("viewerWrap").style.display = "block"
      }

      function encodePath(path) {
        return String(path)
          .split("/")
          .filter(Boolean)
          .map(encodeURIComponent)
          .join("/")
      }

      function libUrl(pathOrUrl) {
        const v = String(pathOrUrl || "").trim()
        if (!v) return ""
        if (v.startsWith("http://") || v.startsWith("https://")) return v
        return "/lib/" + encodePath(v)
      }

      function refreshLink(url) {
        const a = document.getElementById("link")
        a.textContent = url || "—"
        a.href = url || "#"
      }

      function openInNewTab(path) {
        const url = libUrl(path)
        if (!url) return
        refreshLink(url)
        window.open(url, "_blank", "noopener,noreferrer")
      }

      function viewInline(path) {
        const url = libUrl(path)
        if (!url) return
        refreshLink(url)
        showViewer()
        document.getElementById("viewer").src = url
        document.getElementById("viewerWrap").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function openPathInNewTab() {
        const p = document.getElementById("path").value.trim()
        openInNewTab(p)
      }

      function openPathInline() {
        const p = document.getElementById("path").value.trim()
        viewInline(p)
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;")
      }

      function looksLikePath(s) {
        const x = String(s || "").trim()
        if (!x) return false
        if (x.includes("://")) return true
        if ((x.includes("/") || x.includes("\\")) && /\.[a-z0-9]{2,6}$/i.test(x)) return true
        if (/\.(pdf|txt|docx|json|zip|md)$/i.test(x)) return true
        return false
      }

      function looksLikeHashish(s) {
        const x = String(s || "").trim()
        if (!x) return false
        if (/^[0-9a-f]{32}$/i.test(x)) return true
        if (/^[0-9a-f]{40}$/i.test(x)) return true
        if (/^[0-9a-f]{64}$/i.test(x)) return true
        if (/^(sha1|sha256|md5):[0-9a-f]{16,64}$/i.test(x)) return true
        return false
      }

      function normHashish(s) {
        const x = String(s || "").trim()
        if (!x) return ""
        const m = x.match(/^(sha1|sha256|md5):(.+)$/i)
        return (m && m[2] ? m[2] : x).toLowerCase()
      }

      function basenameOf(p) {
        const x = String(p || "").trim()
        if (!x) return ""
        const s = x.replaceAll("\\", "/")
        const parts = s.split("/")
        return (parts[parts.length - 1] || "").trim()
      }

      function stemOfFilename(fn) {
        const x = String(fn || "").trim()
        if (!x) return ""
        return x.replace(/\.[a-z0-9]{2,6}$/i, "")
      }

      async function fetchJsonAny(urls) {
        let lastErr = null
        for (const u of urls) {
          try {
            const r = await fetch(u, { cache: "no-store" })
            if (r.ok) return await r.json()
            lastErr = new Error(`${u} -> HTTP ${r.status}`)
          } catch (e) {
            lastErr = e
          }
        }
        throw lastErr || new Error("fetch failed")
      }

      function objectToArrayMap(obj) {
        const arr = []
        for (const [k, v] of Object.entries(obj || {})) {
          if (v && typeof v === "object") arr.push({ ...v, _key: k })
          else arr.push({ title: String(v ?? "").trim(), _key: k })
        }
        return arr
      }

      function extractBestCollection(json) {
        if (Array.isArray(json)) return json
        if (!json || typeof json !== "object") return []

        let bestArr = null
        let bestLen = -1
        for (const v of Object.values(json)) {
          if (Array.isArray(v) && v.length > bestLen) {
            bestArr = v
            bestLen = v.length
          }
        }
        if (bestArr) return bestArr

        const containerKeys = ["items", "books", "data", "metadata", "list"]
        for (const k of containerKeys) {
          const v = json[k]
          if (Array.isArray(v)) return v
          if (v && typeof v === "object") return objectToArrayMap(v)
        }

        const keys = Object.keys(json)
        if (keys.length) {
          const sampleN = Math.min(keys.length, 500)
          let score = 0
          for (let i = 0; i < sampleN; i++) {
            const kk = keys[i]
            if (looksLikePath(kk) || looksLikeHashish(kk)) score++
          }
          if (score / sampleN >= 0.15) return objectToArrayMap(json)
        }

        let bestObj = null
        let bestObjSize = 0
        for (const v of Object.values(json)) {
          if (v && typeof v === "object" && !Array.isArray(v)) {
            const size = Object.keys(v).length
            if (size > bestObjSize) {
              bestObjSize = size
              bestObj = v
            }
          }
        }
        if (bestObj && bestObjSize > 0) return objectToArrayMap(bestObj)

        return []
      }

      function getAny(o, keys) {
        for (const k of keys) {
          if (o && Object.prototype.hasOwnProperty.call(o, k)) return o[k]
        }
        return undefined
      }

      function normalizeMetaItem(x) {
        const o = (x && typeof x === "object") ? x : {}
        const titleVal = getAny(o, ["title", "name", "he_title", "heb_title", "book", "display", "caption"]) ?? ""
        const authorVal = getAny(o, ["author", "authors", "by", "creator", "writer"]) ?? ""
        const pathVal = getAny(o, ["path", "file", "filename", "relpath", "uri", "url", "href"]) ?? ""
        const idVal = getAny(o, ["id", "book_id", "bookId", "file_id", "fileId", "filehash", "hash", "sha", "sha1", "sha256", "md5"]) ?? (o._key ?? "")

        const title = Array.isArray(titleVal) ? titleVal.join(" ") : titleVal
        const author = Array.isArray(authorVal) ? authorVal.join(", ") : authorVal
        const path = Array.isArray(pathVal) ? pathVal[0] : pathVal

        return {
          title: String(title || "").trim(),
          author: String(author || "").trim(),
          path: String(path || "").trim(),
          id: String(idVal ?? "").trim(),
          _key: String(o._key || "").trim(),
          _raw: o
        }
      }

      function deepCollectStrings(root, maxDepth = 5, maxItems = 250) {
        const out = []
        const seen = new Set()

        function push(v) {
          const s = String(v || "").trim()
          if (!s) return
          if (s.length > 500) return
          if (seen.has(s)) return
          seen.add(s)
          out.push(s)
        }

        function walk(node, depth) {
          if (out.length >= maxItems) return
          if (depth > maxDepth) return
          if (node == null) return

          const t = typeof node
          if (t === "string" || t === "number" || t === "boolean") {
            push(node)
            return
          }
          if (Array.isArray(node)) {
            for (let i = 0; i < node.length; i++) {
              walk(node[i], depth + 1)
              if (out.length >= maxItems) return
            }
            return
          }
          if (t === "object") {
            for (const [k, v] of Object.entries(node)) {
              push(k)
              walk(v, depth + 1)
              if (out.length >= maxItems) return
            }
          }
        }

        walk(root, 0)
        return out
      }

      function extractManifestEntries(manifestJson) {
        if (!manifestJson || typeof manifestJson !== "object") return []
        const v = manifestJson.files || manifestJson.manifest || manifestJson.data || manifestJson
        if (!v || typeof v !== "object" || Array.isArray(v)) return []
        return Object.entries(v)
      }

      function collectStringsFromValue(val) {
        const out = []
        const push = (s) => {
          if (typeof s !== "string") return
          const x = s.trim()
          if (!x) return
          if (x.length > 500) return
          out.push(x)
          const m = x.match(/^(sha1|sha256|md5):(.+)$/i)
          if (m && m[2]) out.push(m[2])
        }

        if (typeof val === "string") {
          push(val)
          return out
        }
        if (val && typeof val === "object") {
          for (const v of Object.values(val)) {
            if (typeof v === "string") push(v)
          }
        }
        return out
      }

      async function buildManifestMaps(manifestJson, onProgress) {
        const hashToPath = new Map()
        const baseToPath = new Map()
        const stemToPath = new Map()
        const entries = extractManifestEntries(manifestJson)
        const total = entries.length

        for (let i = 0; i < total; i++) {
          const [k, vRaw] = entries[i]
          const kStr = String(k || "").trim()
          const vStrings = collectStringsFromValue(vRaw)

          let path = ""
          if (looksLikePath(kStr)) path = kStr
          else {
            for (const s of vStrings) {
              if (looksLikePath(s)) { path = s; break }
            }
          }

          if (path) {
            const b = basenameOf(path).toLowerCase()
            const st = stemOfFilename(b).toLowerCase()
            if (b && !baseToPath.has(b)) baseToPath.set(b, path)
            if (st && !stemToPath.has(st)) stemToPath.set(st, path)

            if (looksLikeHashish(kStr)) {
              const hk = normHashish(kStr)
              if (hk && !hashToPath.has(hk)) hashToPath.set(hk, path)
            }
            for (const s of vStrings) {
              if (looksLikeHashish(s)) {
                const hv = normHashish(s)
                if (hv && !hashToPath.has(hv)) hashToPath.set(hv, path)
              }
              const bb = basenameOf(s).toLowerCase()
              const sst = stemOfFilename(bb).toLowerCase()
              if (bb && !baseToPath.has(bb)) baseToPath.set(bb, path)
              if (sst && !stemToPath.has(sst)) stemToPath.set(sst, path)
            }
          }

          if (i % 5000 === 0) {
            if (onProgress) onProgress(i, total)
            await tick()
          }
        }

        if (onProgress) onProgress(total, total)
        return { hashToPath, baseToPath, stemToPath }
      }

      function resolvePathForMeta(meta, maps) {
        if (looksLikePath(meta.path)) return meta.path

        const strings = deepCollectStrings(meta._raw, 5, 220)

        for (const s of strings) {
          if (!looksLikeHashish(s)) continue
          const h = normHashish(s)
          if (h && maps.hashToPath.has(h)) return maps.hashToPath.get(h)
        }

        for (const s of strings) {
          const b = basenameOf(s).toLowerCase()
          if (b && maps.baseToPath.has(b)) return maps.baseToPath.get(b)
        }

        for (const s of strings) {
          const b = basenameOf(s).toLowerCase()
          const st = stemOfFilename(b).toLowerCase()
          if (st && maps.stemToPath.has(st)) return maps.stemToPath.get(st)
        }

        return ""
      }

      async function buildIndex(list, onProgress) {
        const out = []
        const total = list.length

        for (let i = 0; i < total; i++) {
          const it = list[i]
          const q = (it.title + " " + it.author + " " + it.path).toLowerCase()
          out.push({ ...it, q })

          if (i % 2000 === 0) {
            if (onProgress) onProgress(i, total)
            await tick()
          }
        }

        if (onProgress) onProgress(total, total)
        return out
      }

      function clearResults() {
        document.getElementById("results").innerHTML = ""
        renderCursor = 0
      }

      function renderNextPage() {
        const root = document.getElementById("results")
        const end = Math.min(renderCursor + PAGE_SIZE, currentList.length)

        for (let i = renderCursor; i < end; i++) {
          const it = currentList[i]

          const card = document.createElement("div")
          card.className = "card"

          const t = document.createElement("div")
          t.className = "title"
          t.textContent = it.title || "(ללא כותרת)"

          const m = document.createElement("div")
          m.className = "meta"
          m.textContent = it.author || ""

          const p = document.createElement("div")
          p.className = "path"
          p.textContent = it.path || "(אין נתיב)"

          const actions = document.createElement("div")
          actions.className = "actions"

          const btnView = document.createElement("button")
          btnView.className = "btnSmall"
          btnView.textContent = "צפה כאן"
          btnView.onclick = (e) => {
            e.stopPropagation()
            if (!it.path) return
            viewInline(it.path)
          }

          const btnOpen = document.createElement("button")
          btnOpen.className = "btnSmall"
          btnOpen.textContent = "פתח בטאב"
          btnOpen.onclick = (e) => {
            e.stopPropagation()
            if (!it.path) return
            openInNewTab(it.path)
          }

          actions.appendChild(btnView)
          actions.appendChild(btnOpen)

          // קליק על כל הכרטיס = פתיחה בטאב (מונע “קפיצות”)
          card.onclick = () => {
            if (!it.path) return
            openInNewTab(it.path)
          }

          card.appendChild(t)
          card.appendChild(m)
          card.appendChild(p)
          card.appendChild(actions)

          root.appendChild(card)
        }

        renderCursor = end
      }

      function applySearch() {
        const q = document.getElementById("q").value.trim().toLowerCase()
        const showAll = document.getElementById("showAll").checked

        let base = items
        if (!showAll) base = base.filter(it => it.path)

        currentList = q ? base.filter(it => it.q.includes(q)) : base

        clearResults()
        renderNextPage()

        const withPath = items.filter(it => it.path).length
        const withoutPath = items.length - withPath
        setStatus(`סה"כ: ${items.length} | עם קובץ: ${withPath} | בלי קובץ: ${withoutPath} | מוצג: ${currentList.length}`)
      }

      let searchTimer = null
      function onSearchInput() {
        clearTimeout(searchTimer)
        searchTimer = setTimeout(applySearch, 150)
      }

      async function loadCatalog() {
        setStatus("טוען metadata...")
        document.getElementById("btnLoad").disabled = true

        try {
          const metaJson = await fetchJsonAny([
            "/api/metadata",
            "/lib/metadata.json"
          ])

          const rawMetaItems = extractBestCollection(metaJson)
          if (!rawMetaItems.length) {
            setStatus("נטען metadata אבל לא זוהתה רשימה")
            alert("לא הצלחתי לחלץ רשימת פריטים מתוך metadata.json")
            return
          }

          setStatus(`מעבד metadata... (0/${rawMetaItems.length})`)
          const normalized = []
          for (let i = 0; i < rawMetaItems.length; i++) {
            normalized.push(normalizeMetaItem(rawMetaItems[i]))
            if (i % 3000 === 0) {
              setStatus(`מעבד metadata... (${i}/${rawMetaItems.length})`)
              await tick()
            }
          }
          setStatus(`מעבד metadata... (${rawMetaItems.length}/${rawMetaItems.length})`)

          setStatus("טוען files_manifest...")
          const manifestJson = await fetchJsonAny([
            "/api/manifest",
            "/lib/files_manifest.json"
          ])

          setStatus("בונה מפות מה־manifest...")
          const maps = await buildManifestMaps(manifestJson, (done, total) => {
            setStatus(`בונה מפות מה־manifest... (${done}/${total})`)
          })

          setStatus(`משלים נתיבים... (0/${normalized.length})`)
          let filled = 0
          for (let i = 0; i < normalized.length; i++) {
            const p = resolvePathForMeta(normalized[i], maps)
            normalized[i].path = looksLikePath(p) ? String(p).trim() : ""
            if (normalized[i].path) filled++

            if (i % 1000 === 0) {
              setStatus(`משלים נתיבים... (${i}/${normalized.length}) | נמצאו: ${filled}`)
              await tick()
            }
          }
          setStatus(`משלים נתיבים... (${normalized.length}/${normalized.length}) | נמצאו: ${filled}`)

          setStatus("בונה אינדקס חיפוש...")
          items = await buildIndex(normalized, null)

          document.getElementById("showAll").checked = false
          applySearch()
          scrollToResults()

          window.onscroll = () => {
            if (renderCursor >= currentList.length) return
            const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 400)
            if (nearBottom) renderNextPage()
          }
        } catch (e) {
          console.error(e)
          setStatus("שגיאה")
          alert("שגיאה: " + (e && e.message ? e.message : e))
        } finally {
          document.getElementById("btnLoad").disabled = false
        }
      }

      async function ping() {
        const r = await fetch("/api/ping")
        alert(await r.text())
      }
    </script>
  </body>
</html>
