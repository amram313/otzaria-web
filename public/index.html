<!doctype html>
<!-- public/index.html -->
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ספרייה - קטלוג</title>
    <style>
      :root {
        --bg: #0b1020;
        --card: rgba(255, 255, 255, 0.06);
        --card2: rgba(255, 255, 255, 0.08);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.6);
        --accent: #6dd5fa;
        --accent2: #9a7bff;
        --good: #3ddc97;
        --bad: #ff5c7a;
        --warn: #ffd166;
        --radius: 16px;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: radial-gradient(1200px 600px at 70% -10%, rgba(109, 213, 250, 0.25), transparent 60%),
          radial-gradient(900px 500px at 20% 10%, rgba(154, 123, 255, 0.2), transparent 55%),
          radial-gradient(1000px 600px at 50% 120%, rgba(61, 220, 151, 0.12), transparent 60%),
          var(--bg);
        color: var(--text);
        font-family: var(--sans);
      }

      a {
        color: inherit;
        text-decoration: none;
      }

      .wrap {
        max-width: 1200px;
        margin: 0 auto;
        padding: 22px 14px 60px;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 14px;
      }

      .brand {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .logo {
        width: 42px;
        height: 42px;
        border-radius: 14px;
        background: linear-gradient(135deg, rgba(109, 213, 250, 0.8), rgba(154, 123, 255, 0.8));
        box-shadow: 0 12px 30px rgba(109, 213, 250, 0.18);
      }

      h1 {
        font-size: 18px;
        margin: 0;
        line-height: 1.2;
        letter-spacing: 0.2px;
      }

      .subtitle {
        font-size: 12px;
        color: var(--muted);
        margin-top: 2px;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: var(--shadow);
        user-select: none;
      }

      .pill small {
        color: var(--muted);
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 14px;
        align-items: start;
      }

      @media (max-width: 960px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0.05));
        border: 1px solid rgba(255, 255, 255, 0.09);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .card header {
        margin: 0;
        padding: 14px 14px 0;
      }

      .card .body {
        padding: 14px;
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr 140px 140px;
        gap: 10px;
        margin: 0 0 12px;
      }

      @media (max-width: 720px) {
        .controls {
          grid-template-columns: 1fr;
        }
      }

      input[type="search"],
      select,
      button {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.25);
        color: var(--text);
        outline: none;
      }

      button {
        cursor: pointer;
        background: linear-gradient(135deg, rgba(109, 213, 250, 0.25), rgba(154, 123, 255, 0.25));
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      button:hover {
        border-color: rgba(255, 255, 255, 0.18);
      }

      .muted {
        color: var(--muted);
      }

      .list {
        display: grid;
        gap: 10px;
      }

      .item {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: start;
        padding: 12px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .item:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.12);
      }

      .title {
        font-weight: 700;
        line-height: 1.35;
      }

      .meta {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
        display: flex;
        flex-wrap: wrap;
        gap: 8px 10px;
      }

      .tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 5px 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        font-size: 12px;
        color: var(--muted);
      }

      .tag b {
        color: var(--text);
        font-weight: 700;
      }

      .right {
        display: grid;
        gap: 12px;
      }

      .tree {
        display: grid;
        gap: 6px;
        padding: 12px;
      }

      .node {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 10px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        user-select: none;
      }

      .node:hover {
        border-color: rgba(255, 255, 255, 0.14);
      }

      .node .name {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        min-width: 0;
      }

      .node .name span {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 240px;
      }

      .badge {
        font-family: var(--mono);
        font-size: 11px;
        color: rgba(255, 255, 255, 0.75);
        padding: 3px 8px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.09);
      }

      .footer {
        margin-top: 16px;
        color: var(--muted);
        font-size: 12px;
      }

      .hr {
        height: 1px;
        background: rgba(255, 255, 255, 0.08);
        margin: 10px 0;
      }

      .view {
        display: none;
      }

      .view.active {
        display: block;
      }

      .fileHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
        margin: 0 0 10px;
      }

      .crumbs {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
      }

      .crumbs a {
        color: rgba(255, 255, 255, 0.82);
      }

      .crumbs .sep {
        color: rgba(255, 255, 255, 0.25);
      }

      .actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .actions button {
        width: auto;
        padding: 10px 12px;
      }

      pre {
        margin: 0;
        padding: 14px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.08);
        overflow: auto;
        font-family: var(--mono);
        font-size: 13px;
        line-height: 1.55;
        color: rgba(255, 255, 255, 0.92);
        white-space: pre-wrap;
        word-break: break-word;
      }

      .statusLine {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        font-size: 12px;
        color: var(--muted);
      }

      .statusDot {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.25);
      }

      .statusDot.good {
        background: var(--good);
      }

      .statusDot.bad {
        background: var(--bad);
      }

      .statusDot.warn {
        background: var(--warn);
      }

      .kbd {
        font-family: var(--mono);
        font-size: 11px;
        padding: 3px 6px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .small {
        font-size: 12px;
      }

      .split {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="brand">
          <div class="logo"></div>
          <div>
            <h1>ספרייה - קטלוג</h1>
            <div class="subtitle">חיפוש וניווט בקבצי הטקסט מתוך המאגר</div>
          </div>
        </div>

        <div class="pill">
          <div class="statusDot" id="statusDot"></div>
          <div>
            <div class="small">מצב חיבור: <b id="statusText">בודק…</b></div>
            <small id="statusHint">/api/ping</small>
          </div>
        </div>
      </header>

      <div class="grid">
        <div class="card">
          <header>
            <div class="controls">
              <input id="q" type="search" placeholder="חפש לפי שם, מחבר, מקור, תגיות..." autocomplete="off" />
              <select id="sort">
                <option value="title">מיון: כותרת</option>
                <option value="path">מיון: נתיב</option>
                <option value="author">מיון: מחבר</option>
              </select>
              <button id="refresh">כפה רענון</button>
            </div>
            <div class="statusLine">
              <div class="split">
                <span class="muted">נמצאו <b id="count">0</b> קבצים</span>
                <span class="muted">|</span>
                <span class="muted">מסונן: <b id="filtered">0</b></span>
              </div>
              <div class="muted">קיצורי מקלדת: <span class="kbd">/</span> חיפוש, <span class="kbd">Esc</span> ניקוי</div>
            </div>
          </header>
          <div class="body">
            <div id="viewCatalog" class="view active">
              <div class="list" id="list"></div>
              <div class="footer" id="footer"></div>
            </div>

            <div id="viewFile" class="view">
              <div class="fileHeader">
                <div>
                  <div class="crumbs" id="crumbs"></div>
                  <div class="title" id="fileTitle"></div>
                  <div class="meta" id="fileMeta"></div>
                </div>
                <div class="actions">
                  <button id="back">חזרה</button>
                  <button id="openRaw">פתח קובץ</button>
                  <button id="copyLink">העתק קישור</button>
                </div>
              </div>

              <div class="hr"></div>

              <pre id="fileContent">טוען…</pre>

              <div class="footer" id="fileFooter"></div>
            </div>
          </div>
        </div>

        <div class="right">
          <div class="card">
            <header>
              <div class="muted">קטגוריות</div>
            </header>
            <div class="tree" id="tree"></div>
          </div>

          <div class="card">
            <header>
              <div class="muted">מידע</div>
            </header>
            <div class="body">
              <div class="muted">
                הנתונים נטענים מתוך:
                <span class="kbd">/api/manifest</span>
                + <span class="kbd">/api/metadata</span>
              </div>
              <div class="hr"></div>
              <div class="muted small" id="infoBox">טוען…</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ----------------------------
      // Config
      // ----------------------------
      const API_MANIFEST = "/api/manifest"
      const API_METADATA = "/api/metadata"
      const API_PING = "/api/ping"
      const API_LIB = "/lib"
      const PAGE_SIZE = 60

      // ----------------------------
      // State
      // ----------------------------
      const state = {
        items: [],
        filtered: [],
        meta: {},
        catTree: null,
        selectedCat: [],
        page: 1,
        view: "catalog",
        file: null,
        cacheKey: "otzaria_catalog_cache_v3",
        cacheMetaKey: "otzaria_meta_cache_v3",
      }

      // ----------------------------
      // UI refs
      // ----------------------------
      const $ = (id) => document.getElementById(id)
      const elList = $("list")
      const elTree = $("tree")
      const elCount = $("count")
      const elFiltered = $("filtered")
      const elFooter = $("footer")
      const elStatusDot = $("statusDot")
      const elStatusText = $("statusText")
      const elStatusHint = $("statusHint")
      const elViewCatalog = $("viewCatalog")
      const elViewFile = $("viewFile")
      const elQ = $("q")
      const elSort = $("sort")
      const elInfoBox = $("infoBox")

      const elCrumbs = $("crumbs")
      const elFileTitle = $("fileTitle")
      const elFileMeta = $("fileMeta")
      const elFileContent = $("fileContent")
      const elFileFooter = $("fileFooter")

      // Buttons
      $("refresh").addEventListener("click", () => loadAll({ force: true }))
      $("back").addEventListener("click", () => {
        history.pushState({}, "", location.pathname)
        showCatalog()
      })
      $("openRaw").addEventListener("click", () => {
        if (!state.file) return
        const url = `${API_LIB}/${encodeURI(state.file.path)}`
        window.open(url, "_blank", "noopener,noreferrer")
      })
      $("copyLink").addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(location.href)
        } catch (_) {}
      })

      // Keyboard shortcuts
      window.addEventListener("keydown", (e) => {
        if (e.key === "/" && document.activeElement !== elQ) {
          e.preventDefault()
          elQ.focus()
        }
        if (e.key === "Escape") {
          if (document.activeElement === elQ) {
            elQ.value = ""
            applyFilters()
          }
        }
      })

      // Search input
      elQ.addEventListener("input", () => {
        state.page = 1
        applyFilters()
      })
      elSort.addEventListener("change", () => {
        state.page = 1
        applyFilters()
      })

      // Routing
      window.addEventListener("popstate", () => route(location.pathname + location.search))
      function route(full) {
        const u = new URL(full, location.origin)
        const p = u.pathname
        const id = u.searchParams.get("file")
        if (p === "/file" && id) {
          const it = findById(id)
          if (it) showFile(it)
          else showCatalog()
        } else {
          showCatalog()
        }
      }

      // ----------------------------
      // Utils
      // ----------------------------
      function escapeHtml(s) {
        return String(s || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;")
      }

      function normalize(s) {
        return String(s || "")
          .trim()
          .toLowerCase()
          .replace(/\s+/g, " ")
      }

      function pick(obj, key, fallback = "") {
        const v = obj && obj[key]
        return v == null ? fallback : v
      }

      function uniq(arr) {
        return Array.from(new Set(arr))
      }

      function joinCrumbs(arr) {
        return (arr || []).filter(Boolean).join(" / ")
      }

      function isObj(x) {
        return x && typeof x === "object" && !Array.isArray(x)
      }

      // ----------------------------
      // Data load + caching
      // ----------------------------
      async function ping() {
        try {
          const r = await fetch(API_PING, { method: "GET" })
          if (!r.ok) throw new Error("bad")
          elStatusDot.className = "statusDot good"
          elStatusText.textContent = "מחובר"
          elStatusHint.textContent = API_PING
        } catch (_) {
          elStatusDot.className = "statusDot bad"
          elStatusText.textContent = "לא זמין"
          elStatusHint.textContent = "בדוק פריסה / פונקציות"
        }
      }

      async function loadAll({ force } = { force: false }) {
        await ping()

        const cached = await readCache(force)
        if (cached) {
          state.items = cached.items || []
          state.meta = cached.meta || {}
          hydrateItems()
          buildTreeAndRender()
          applyFilters()
          renderInfoBox()
          route(location.pathname + location.search)
          return
        }

        elInfoBox.textContent = "טוען נתונים מהשרת…"

        try {
          const [manifest, metadata] = await Promise.all([fetchJson(API_MANIFEST), fetchJson(API_METADATA)])

          const items = Array.isArray(manifest) ? manifest : manifest?.files || []
          const meta = isObj(metadata) ? metadata : {}

          state.items = items.map((x) => normalizeItem(x))
          state.meta = meta

          hydrateItems()
          buildTreeAndRender()
          applyFilters()
          renderInfoBox()

          await writeCache()
          route(location.pathname + location.search)
        } catch (err) {
          elInfoBox.textContent = "שגיאה בטעינת נתונים. בדוק /api/manifest ו-/api/metadata."
          elStatusDot.className = "statusDot warn"
          elStatusText.textContent = "שגיאת טעינה"
          elStatusHint.textContent = String(err?.message || err)
        }
      }

      async function fetchJson(url) {
        const r = await fetch(url, { method: "GET" })
        if (!r.ok) throw new Error(`Fetch failed: ${r.status}\n${url}`)
        return await r.json()
      }

      async function readCache(force) {
        if (force) return null
        try {
          const raw = localStorage.getItem(state.cacheKey)
          const rawMeta = localStorage.getItem(state.cacheMetaKey)
          if (!raw || !rawMeta) return null
          const obj = JSON.parse(raw)
          const meta = JSON.parse(rawMeta)
          if (!obj || !meta) return null
          return { items: obj.items, meta }
        } catch (_) {
          return null
        }
      }

      async function writeCache() {
        try {
          localStorage.setItem(state.cacheKey, JSON.stringify({ items: state.items }))
          localStorage.setItem(state.cacheMetaKey, JSON.stringify(state.meta))
        } catch (_) {}
      }

      // ----------------------------
      // Manifest normalization
      // ----------------------------
      function normalizeItem(x) {
        if (typeof x === "string") {
          return { path: x }
        }
        if (!isObj(x)) return {}
        const it = { ...x }
        if (!it.path && it.file) it.path = it.file
        return it
      }

      function buildIdFromPath(path) {
        return btoa(unescape(encodeURIComponent(path))).replaceAll("=", "")
      }

      function hydrateItems() {
        for (const it of state.items) {
          if (!it.path) continue
          it.id = it.id || buildIdFromPath(it.path)
          it.title = it.title || guessTitleFromPath(it.path)
          it.author = it.author || ""
          it.source = it.source || ""
          it.tags = Array.isArray(it.tags) ? it.tags : []
          it.cat = Array.isArray(it.cat) ? it.cat : null
        }

        // Join metadata by path/id if exists
        const metaByPath = isObj(state.meta?.byPath) ? state.meta.byPath : null
        const metaById = isObj(state.meta?.byId) ? state.meta.byId : null

        if (metaByPath || metaById) {
          for (const it of state.items) {
            const keyPath = it.path
            const keyId = it.id
            const m = (metaByPath && metaByPath[keyPath]) || (metaById && metaById[keyId]) || null
            if (m && isObj(m)) {
              it.title = it.title || pick(m, "title", "")
              it.author = it.author || pick(m, "author", "")
              it.source = it.source || pick(m, "source", "")
              const t = m.tags
              if (Array.isArray(t) && t.length) it.tags = uniq([...(it.tags || []), ...t])
              const c = m.cat
              if (Array.isArray(c) && c.length) it.cat = c
            }
          }
        }
      }

      function guessTitleFromPath(p) {
        const parts = String(p || "").split("/").filter(Boolean)
        if (!parts.length) return ""
        const last = parts[parts.length - 1]
        return last.replace(/\.[^.]+$/, "")
      }

      // ----------------------------
      // Category tree
      // ----------------------------
      function computeCategoryFromPath(p) {
        const x = String(p || "").trim()
        if (!x) return []
        if (x.startsWith("http://") || x.startsWith("https://")) return []
        const parts = x.replaceAll("\\", "/").split("/").filter(Boolean)

        // אם "ספרים" מופיע בנתיב, נתחיל ממנו כדי לא להציג פרפיקסים טכניים (כמו DictaToOtzaria וכו')
        const booksIdx = parts.indexOf("ספרים")
        const start = booksIdx >= 0 && booksIdx < parts.length - 1 ? booksIdx + 1 : 0

        if (parts.length - start <= 1) return []
        // קטגוריה = כל התיקיות (ללא שם הקובץ)
        return parts.slice(start, parts.length - 1)
      }

      function buildCategoryTree(list) {
        const root = { name: "", segs: [], count: 0, children: new Map() }
        function getChild(parent, name, segs) {
          if (!parent.children.has(name)) {
            parent.children.set(name, { name, segs, count: 0, children: new Map() })
          }
          return parent.children.get(name)
        }

        for (const it of list) {
          if (!it.path) continue
          const segs = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)
          let node = root
          node.count++
          for (let i = 0; i < segs.length; i++) {
            const s = String(segs[i] || "").trim()
            if (!s) continue
            const nextSegs = segs.slice(0, i + 1)
            node = getChild(node, s, nextSegs)
            node.count++
          }
        }

        return root
      }

      function treeToArray(node) {
        const arr = []
        for (const child of node.children.values()) {
          arr.push(child)
        }
        arr.sort((a, b) => a.name.localeCompare(b.name, "he"))
        return arr
      }

      function buildTreeAndRender() {
        state.catTree = buildCategoryTree(state.items)
        renderTree()
      }

      function renderTree() {
        elTree.innerHTML = ""
        const root = state.catTree
        if (!root) return

        const stack = [{ node: root, depth: 0 }]
        while (stack.length) {
          const cur = stack.shift()
          const children = treeToArray(cur.node)
          for (const child of children) {
            const row = document.createElement("div")
            row.className = "node"
            row.style.marginRight = `${cur.depth * 10}px`

            const nameBox = document.createElement("div")
            nameBox.className = "name"

            const arrow = document.createElement("span")
            arrow.textContent = "›"
            arrow.style.opacity = "0.7"
            nameBox.appendChild(arrow)

            const name = document.createElement("span")
            name.textContent = child.name
            nameBox.appendChild(name)

            const badge = document.createElement("div")
            badge.className = "badge"
            badge.textContent = String(child.count)

            row.appendChild(nameBox)
            row.appendChild(badge)

            row.addEventListener("click", () => {
              state.selectedCat = child.segs
              state.page = 1
              applyFilters()
            })

            elTree.appendChild(row)

            if (child.children && child.children.size) {
              stack.push({ node: child, depth: cur.depth + 1 })
            }
          }
        }
      }

      // ----------------------------
      // Filtering + sorting + paging
      // ----------------------------
      function applyFilters() {
        const q = normalize(elQ.value)
        const selected = state.selectedCat || []

        let list = state.items.filter((it) => !!it.path)

        if (selected.length) {
          list = list.filter((it) => {
            const segs = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)
            if (!segs || segs.length < selected.length) return false
            for (let i = 0; i < selected.length; i++) {
              if (String(segs[i]) !== String(selected[i])) return false
            }
            return true
          })
        }

        if (q) {
          list = list.filter((it) => {
            const hay = normalize(
              [it.title, it.author, it.source, it.path, ...(it.tags || []), joinCrumbs(it.cat || [])].join(" ")
            )
            return hay.includes(q)
          })
        }

        const sortKey = elSort.value
        list.sort((a, b) => {
          const av = normalize(a[sortKey] || "")
          const bv = normalize(b[sortKey] || "")
          return av.localeCompare(bv, "he")
        })

        state.filtered = list
        renderList()
      }

      function renderList() {
        elList.innerHTML = ""
        const total = state.items.length
        const count = state.filtered.length

        elCount.textContent = String(total)
        elFiltered.textContent = String(count)

        const start = (state.page - 1) * PAGE_SIZE
        const pageItems = state.filtered.slice(start, start + PAGE_SIZE)

        for (const it of pageItems) {
          const row = document.createElement("a")
          row.className = "item"
          row.href = `/file?file=${encodeURIComponent(it.id)}`
          row.addEventListener("click", (e) => {
            e.preventDefault()
            history.pushState({}, "", row.href)
            showFile(it)
          })

          const left = document.createElement("div")
          const t = document.createElement("div")
          t.className = "title"
          t.textContent = it.title || guessTitleFromPath(it.path)

          const meta = document.createElement("div")
          meta.className = "meta"

          const segs = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)
          const cat = joinCrumbs(segs)
          if (cat) meta.appendChild(makeTag("קטגוריה", cat))
          if (it.author) meta.appendChild(makeTag("מחבר", it.author))
          if (it.source) meta.appendChild(makeTag("מקור", it.source))
          if (Array.isArray(it.tags) && it.tags.length) meta.appendChild(makeTag("תגיות", it.tags.slice(0, 6).join(", ")))

          left.appendChild(t)
          left.appendChild(meta)

          const right = document.createElement("div")
          right.className = "badge"
          right.textContent = it.path.split("/").pop()

          row.appendChild(left)
          row.appendChild(right)
          elList.appendChild(row)
        }

        renderPager()
      }

      function makeTag(k, v) {
        const span = document.createElement("span")
        span.className = "tag"
        span.innerHTML = `<b>${escapeHtml(k)}:</b> ${escapeHtml(v)}`
        return span
      }

      function renderPager() {
        const total = state.filtered.length
        const pages = Math.max(1, Math.ceil(total / PAGE_SIZE))
        state.page = Math.min(state.page, pages)

        const cat = state.selectedCat && state.selectedCat.length ? `קטגוריה: ${joinCrumbs(state.selectedCat)}` : "ללא סינון"

        elFooter.innerHTML = ""
        const box = document.createElement("div")
        box.className = "muted"
        box.style.display = "flex"
        box.style.justifyContent = "space-between"
        box.style.alignItems = "center"
        box.style.gap = "10px"
        box.style.flexWrap = "wrap"

        const left = document.createElement("div")
        left.textContent = `${cat} | עמוד ${state.page} מתוך ${pages}`

        const right = document.createElement("div")
        right.style.display = "flex"
        right.style.gap = "8px"
        right.style.alignItems = "center"
        right.style.flexWrap = "wrap"

        const prev = document.createElement("button")
        prev.textContent = "הקודם"
        prev.disabled = state.page <= 1
        prev.addEventListener("click", () => {
          state.page = Math.max(1, state.page - 1)
          renderList()
        })

        const next = document.createElement("button")
        next.textContent = "הבא"
        next.disabled = state.page >= pages
        next.addEventListener("click", () => {
          state.page = Math.min(pages, state.page + 1)
          renderList()
        })

        const clearCat = document.createElement("button")
        clearCat.textContent = "איפוס קטגוריה"
        clearCat.disabled = !(state.selectedCat && state.selectedCat.length)
        clearCat.addEventListener("click", () => {
          state.selectedCat = []
          state.page = 1
          applyFilters()
        })

        right.appendChild(prev)
        right.appendChild(next)
        right.appendChild(clearCat)

        box.appendChild(left)
        box.appendChild(right)

        elFooter.appendChild(box)
      }

      // ----------------------------
      // File view
      // ----------------------------
      function showCatalog() {
        state.view = "catalog"
        elViewCatalog.classList.add("active")
        elViewFile.classList.remove("active")
      }

      function showFile(it) {
        state.view = "file"
        state.file = it
        elViewCatalog.classList.remove("active")
        elViewFile.classList.add("active")

        const segs = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)

        elCrumbs.innerHTML = ""
        const rootA = document.createElement("a")
        rootA.href = "/"
        rootA.textContent = "קטלוג"
        rootA.addEventListener("click", (e) => {
          e.preventDefault()
          history.pushState({}, "", "/")
          showCatalog()
        })
        elCrumbs.appendChild(rootA)

        for (const s of segs) {
          const sep = document.createElement("span")
          sep.className = "sep"
          sep.textContent = "›"
          elCrumbs.appendChild(sep)

          const a = document.createElement("a")
          a.href = "#"
          a.textContent = s
          a.addEventListener("click", (e) => {
            e.preventDefault()
            state.selectedCat = segs.slice(0, segs.indexOf(s) + 1)
            history.pushState({}, "", "/")
            showCatalog()
            applyFilters()
          })
          elCrumbs.appendChild(a)
        }

        elFileTitle.textContent = it.title || guessTitleFromPath(it.path)

        const meta = []
        if (it.author) meta.push(makeTag("מחבר", it.author))
        if (it.source) meta.push(makeTag("מקור", it.source))
        if (Array.isArray(it.tags) && it.tags.length) meta.push(makeTag("תגיות", it.tags.join(", ")))
        meta.push(makeTag("נתיב", it.path))
        elFileMeta.innerHTML = ""
        for (const t of meta) elFileMeta.appendChild(t)

        loadFileContent(it)
      }

      async function loadFileContent(it) {
        elFileContent.textContent = "טוען…"
        const url = `${API_LIB}/${encodeURI(it.path)}`
        elFileFooter.textContent = url

        try {
          const r = await fetch(url, { method: "GET" })
          if (!r.ok) throw new Error(`Fetch failed: ${r.status}\n${url}`)
          const text = await r.text()
          elFileContent.textContent = text
        } catch (err) {
          elFileContent.textContent = String(err?.message || err)
        }
      }

      function findById(id) {
        return state.items.find((x) => x.id === id) || null
      }

      function renderInfoBox() {
        const total = state.items.length
        const hasMetaByPath = !!state.meta?.byPath
        const hasMetaById = !!state.meta?.byId
        const metaHint =
          hasMetaByPath || hasMetaById
            ? "metadata.json: נמצא"
            : "metadata.json: לא נמצא (עדיין אפשר לעבוד עם manifest בלבד)"
        elInfoBox.textContent = `קבצים: ${total} | ${metaHint}`
      }

      // Init
      loadAll({ force: false })
      route(location.pathname + location.search)
    </script>
  </body>
</html>
