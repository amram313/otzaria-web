<!-- public/index.html -->
<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ספרייה - קטלוג</title>
    <style>
      :root{
        --bg: #ffffff;
        --muted: #666;
        --border: #e6e6e6;
        --card: #ffffff;
        --shadow: 0 1px 2px rgba(0,0,0,.06);
        --radius: 12px;
        --sidebarW: 320px;
      }

      body{
        font-family: system-ui, Arial;
        margin: 0;
        background: var(--bg);
      }

      .header{
        position: sticky;
        top: 0;
        z-index: 10;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
        padding: 14px 16px;
      }

      .hTitle{
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      h2{ margin: 0; font-size: 20px; }
      .muted{ color: var(--muted); font-size: 13px; }

      .toolbar{
        margin-top: 10px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .pill{
        padding: 4px 8px;
        border: 1px solid var(--border);
        border-radius: 999px;
        font-size: 12px;
        color: #444;
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }

      input[type="text"]{
        width: 100%;
        padding: 10px;
        font-size: 16px;
        border: 1px solid var(--border);
        border-radius: 10px;
      }

      button{
        padding: 10px 12px;
        font-size: 14px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: #fff;
        cursor: pointer;
      }
      button:disabled{ opacity: .6; cursor: not-allowed; }

      .btnSmall{
        padding: 6px 10px;
        font-size: 13px;
        border-radius: 10px;
      }

      .layout{
        display: grid;
        grid-template-columns: var(--sidebarW) 1fr;
        gap: 16px;
        padding: 16px;
        align-items: start;
      }

      @media (max-width: 980px){
        .layout{ grid-template-columns: 1fr; }
        .sidebar{ position: static; }
      }

      .sidebar{
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 10px;
        position: sticky;
        top: 132px;
        max-height: calc(100vh - 160px);
        overflow: auto;
        background: var(--card);
      }

      .sideTop{
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 4px 6px 10px 6px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 8px;
      }

      .sideTitle{ font-weight: 700; }

      .catRow{
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 0;
      }

      .catToggle{
        width: 28px;
        padding: 6px 0;
        text-align: center;
      }

      .catBtn{
        flex: 1;
        text-align: right;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid transparent;
        background: transparent;
      }
      .catBtn:hover{ border-color: var(--border); background: #fafafa; }
      .catBtn.selected{ border-color: #cfe1ff; background: #f4f8ff; }

      .main{
        min-width: 0;
      }

      .resultsHeader{
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
      }

      .grid{
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin-top: 10px;
      }

      .card{
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 10px;
        background: var(--card);
        box-shadow: var(--shadow);
        cursor: pointer;
      }

      .title{ font-weight: 700; }
      .meta{ margin-top: 6px; color: #444; font-size: 14px; }
      .path{ margin-top: 6px; color: #888; font-size: 12px; direction: ltr; text-align: left; word-break: break-all; }
      .actions{ display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }

      a{ color: #0b57d0; }

      /* Viewer (modal) */
      .viewerModal{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.35);
        display: none;
        z-index: 1000;
        padding: 18px;
      }
      .viewerModal.show{ display: block; }
      .viewerCard{
        max-width: 1200px;
        margin: 0 auto;
        height: calc(100vh - 36px);
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 12px 42px rgba(0,0,0,.24);
        border: 1px solid var(--border);
        display: grid;
        grid-template-rows: auto 1fr;
        overflow: hidden;
      }
      .viewerTop{
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 12px;
        border-bottom: 1px solid var(--border);
      }
      .viewerTop .muted{ font-size: 12px; }
      iframe{
        width: 100%;
        height: 100%;
        border: 0;
      }
    </style>
  </head>

  <body>
    <div class="header">
      <div class="hTitle">
        <div>
          <h2>ספרייה — קטלוג</h2>
          <div class="muted">
            קטגוריות נבנות לפי נתיבי התיקיות. החיפוש עובד על כל הקטלוג (גם פריטים שעוד לא הוצגו במסך).
          </div>
        </div>
        <span id="status" class="pill">לא נטען</span>
      </div>

      <div class="toolbar">
        <button id="btnLoad" onclick="refreshCatalog(true)">כפה רענון</button>
        <button class="btnSmall" onclick="scrollToResults()">לתוצאות</button>
        <button class="btnSmall" onclick="openPathInNewTab()">פתח נתיב ידני בטאב</button>
        <button class="btnSmall" onclick="openPathInline()">צפה בנתיב ידני כאן</button>
        <button class="btnSmall" onclick="ping()">בדיקה: /api/ping</button>

        <label class="pill">
          מצב תצוגה:
          <select id="fileMode" onchange="applySearch()">
            <option value="with" selected>רק עם קובץ</option>
            <option value="without">רק בלי קובץ</option>
            <option value="all">הכל</option>
          </select>
        </label>

        <button class="btnSmall" onclick="clearQuery()">נקה חיפוש</button>
        <button class="btnSmall" onclick="downloadMissing()">הורד רשימת חסרים</button>

        <label class="pill">
          <input id="searchAllCats" type="checkbox" onchange="applySearch()" />
          חיפוש בכל הקטגוריות
        </label>
      </div>

      <div class="actions">
        <input id="q" type="text" placeholder="חיפוש (כותרת/מחבר/נתיב)..." oninput="onSearchInput()" />
      </div>

      <div class="actions">
        <input id="path" type="text" placeholder="נתיב ידני בתוך הריפו (למשל: .../file.pdf)" />
        <div class="muted">
          קישור נוכחי: <a id="link" href="#" target="_blank" rel="noreferrer">—</a>
        </div>
      </div>
    </div>

    <div class="layout">
      <aside class="sidebar">
        <div class="sideTop">
          <div class="sideTitle">קטגוריות</div>
          <button class="btnSmall" onclick="clearCategory()">הכל</button>
        </div>
        <div id="cats" class="muted">—</div>
      </aside>

      <main class="main">
        <div class="resultsHeader">
          <h3 id="resultsTitle" style="margin:0;">תוצאות</h3>
          <div class="muted" id="scopeHint"></div>
        </div>
        <div id="results" class="grid"></div>
      </main>
    </div>

    <div id="viewerWrap" class="viewerModal" onclick="onViewerBackdrop(event)">
      <div class="viewerCard">
        <div class="viewerTop">
          <div>
            <div style="font-weight:700;">צפייה בתוך הדף</div>
            <div class="muted">אפשר לסגור עם ESC או קליק מחוץ לחלון.</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="btnSmall" onclick="openViewerInNewTab()">פתח בטאב</button>
            <button class="btnSmall" onclick="hideViewer()">סגור</button>
          </div>
        </div>
        <iframe id="viewer" title="viewer"></iframe>
      </div>
    </div>

    <script>
      // =========================
      // State
      // =========================
      let items = []
      let lastMaps = null
      let currentList = []
      let renderCursor = 0
      const PAGE_SIZE = 60

      let categoryRoot = null
      let selectedCategorySegs = []
      let expandedCategoryKeys = new Set()

      let lastViewerPath = ""

      // Cache settings
      const IDB_DB = "otzaria_catalog"
      const IDB_STORE = "kv"
      const CATALOG_KEY = "catalog_v1"
      const MAX_CATALOG_AGE_MS = 12 * 60 * 60 * 1000 // 12 שעות

      // =========================
      // UI helpers
      // =========================
      function setStatus(text) {
        document.getElementById("status").textContent = text
      }

      function tick() {
        return new Promise(r => setTimeout(r, 0))
      }

      function scrollToResults() {
        document.getElementById("resultsTitle").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function escapeHtml(s) {
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;")
      }

      function encodePath(path) {
        return String(path ?? "")
          .split("/")
          .filter(Boolean)
          .map((seg) => encodePreservePct(seg, encodeURIComponentStrict))
          .join("/")
      }

      function encodeQueryValue(v) {
        // ב-query רצוי לקודד גם /, ולכן משתמשים ב-encodeURIComponentStrict על כל המחרוזת
        return encodePreservePct(String(v ?? ""), encodeURIComponentStrict)
      }

      function libUrl(pathOrUrl) {
        const v = String(pathOrUrl || "").trim()
        if (!v) return ""
        if (v.startsWith("http://") || v.startsWith("https://")) return v
        return "/lib/" + encodePath(v)
      }

      function refreshLink(url) {
        const a = document.getElementById("link")
        a.textContent = url || "—"
        a.href = url || "#"
      }

      function openInNewTab(path) {
        const p = String(path || "").trim()
        if (!p) return
        const viewer = "/view?path=" + encodeQueryValue(p)
        refreshLink(viewer)
        window.open(viewer, "_blank", "noopener,noreferrer")
      }

      function viewInline(path) {
        const p = String(path || "").trim()
        if (!p) return
        lastViewerPath = p
        const viewerUrl = "/view?path=" + encodeQueryValue(p)
        refreshLink(viewerUrl)
        showViewer(viewerUrl)
      }

      function showViewer(viewerUrl) {
        const wrap = document.getElementById("viewerWrap")
        wrap.classList.add("show")
        document.getElementById("viewer").src = viewerUrl
      }

      function hideViewer() {
        const wrap = document.getElementById("viewerWrap")
        wrap.classList.remove("show")
        const iframe = document.getElementById("viewer")
        iframe.src = "about:blank"
      }

      function onViewerBackdrop(e) {
        if (e.target && e.target.id === "viewerWrap") hideViewer()
      }

      function openViewerInNewTab() {
        if (!lastViewerPath) return
        openInNewTab(lastViewerPath)
      }

      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") hideViewer()
      })

      function openPathInNewTab() {
        const p = document.getElementById("path").value.trim()
        if (!p) return alert("הזן נתיב ידני")
        openInNewTab(p)
      }

      function openPathInline() {
        const p = document.getElementById("path").value.trim()
        if (!p) return alert("הזן נתיב ידני")
        viewInline(p)
      }

      async function ping() {
        try {
          const r = await fetch("/api/ping", { cache: "no-store" })
          alert("ping: " + r.status + " " + (await r.text()))
        } catch (e) {
          alert("ping error: " + (e && e.message ? e.message : e))
        }
      }

      // =========================
      // IndexedDB (persistent cache)
      // =========================
      function openDb() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(IDB_DB, 1)
          req.onupgradeneeded = () => {
            const db = req.result
            if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE)
          }
          req.onsuccess = () => resolve(req.result)
          req.onerror = () => reject(req.error)
        })
      }

      async function idbGet(key) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly")
          const store = tx.objectStore(IDB_STORE)
          const r = store.get(key)
          r.onsuccess = () => resolve(r.result)
          r.onerror = () => reject(r.error)
        })
      }

      async function idbSet(key, val) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite")
          const store = tx.objectStore(IDB_STORE)
          const r = store.put(val, key)
          r.onsuccess = () => resolve(true)
          r.onerror = () => reject(r.error)
        })
      }

      async function idbDel(key) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite")
          const store = tx.objectStore(IDB_STORE)
          const r = store.delete(key)
          r.onsuccess = () => resolve(true)
          r.onerror = () => reject(r.error)
        })
      }

      // =========================
      // Catalog loading (keeps old retrieval logic)
      // =========================
      async function fetchJsonAny(urls) {
        let lastErr = null
        for (const u of urls) {
          try {
            const r = await fetch(u, { cache: "no-store" })
            if (r.ok) return await r.json()
            lastErr = new Error(`${u} -> HTTP ${r.status}`)
          } catch (e) {
            lastErr = e
          }
        }
        throw lastErr || new Error("fetchJsonAny failed")
      }

      function objectToArrayMap(obj) {
        const arr = []
        for (const [k, v] of Object.entries(obj || {})) {
          if (v && typeof v === "object") arr.push({ ...v, _key: k })
          else arr.push({ title: String(v ?? "").trim(), _key: k })
        }
        return arr
      }

      function extractBestCollection(json) {
        if (Array.isArray(json)) return json
        if (!json || typeof json !== "object") return []

        let bestArr = null
        let bestLen = -1
        for (const v of Object.values(json)) {
          if (Array.isArray(v) && v.length > bestLen) {
            bestArr = v
            bestLen = v.length
          }
        }
        if (bestArr) return bestArr

        const containerKeys = ["items", "books", "data", "metadata", "list"]
        for (const k of containerKeys) {
          const v = json[k]
          if (Array.isArray(v)) return v
          if (v && typeof v === "object") return objectToArrayMap(v)
        }

        const keys = Object.keys(json)
        if (keys.length) {
          const sampleN = Math.min(keys.length, 500)
          let score = 0
          for (let i = 0; i < sampleN; i++) {
            const v = json[keys[i]]
            if (v && typeof v === "object") score++
          }
          if (score >= Math.floor(sampleN * 0.6)) {
            return objectToArrayMap(json)
          }
        }

        return []
      }

      function getAny(o, keys) {
        for (const k of keys) {
          if (o && Object.prototype.hasOwnProperty.call(o, k)) return o[k]
        }
        return null
      }

      function normalizeMetaItem(x) {
        const o = (x && typeof x === "object") ? x : {}
        const titleVal = getAny(o, ["title", "name", "he_title", "heb_title", "book", "display", "caption"]) ?? ""
        const authorVal = getAny(o, ["author", "authors", "by", "creator", "writer"]) ?? ""
        const pathVal = getAny(o, ["path", "file", "filename", "relpath", "uri", "url", "href"]) ?? ""
        const idVal = getAny(o, ["id", "book_id", "bookId", "...", "hash", "sha", "sha1", "sha256", "md5"]) ?? (o._key ?? "")

        const title = Array.isArray(titleVal) ? titleVal.join(" ") : titleVal
        const author = Array.isArray(authorVal) ? authorVal.join(", ") : authorVal
        const path = Array.isArray(pathVal) ? pathVal[0] : pathVal

        return {
          title: String(title || "").trim(),
          author: String(author || "").trim(),
          path: String(path || "").trim(),
          id: String(idVal ?? "").trim(),
          _key: String(o._key || "").trim(),
          _raw: o
        }
      }

      function deepCollectStrings(root, maxDepth = 5, maxItems = 250) {
        const out = []
        const seen = new Set()

        function push(v) {
          const s = String(v || "").trim()
          if (!s) return
          if (s.length > 500) return
          if (seen.has(s)) return
          seen.add(s)
          out.push(s)
        }

        function walk(node, depth) {
          if (out.length >= maxItems) return
          if (depth > maxDepth) return
          if (node == null) return

          const t = typeof node
          if (t === "string" || t === "number" || t === "boolean") {
            push(node)
            return
          }
          if (Array.isArray(node)) {
            for (let i = 0; i < node.length; i++) {
              walk(node[i], depth + 1)
              if (out.length >= maxItems) return
            }
            return
          }
          if (t === "object") {
            for (const [k, v] of Object.entries(node)) {
              push(k)
              walk(v, depth + 1)
              if (out.length >= maxItems) return
            }
          }
        }

        walk(root, 0)
        return out
      }

      function looksLikePath(s) {
        const x = String(s || "").trim()
        if (!x) return false
        if (x.startsWith("http://") || x.startsWith("https://")) return true
        if (x.includes("/")) return true
        if (x.includes("\\")) return true
        if (x.match(/\.[a-z0-9]{2,6}$/i)) return true
        return false
      }

      function looksLikeHashish(s) {
        const x = String(s || "").trim()
        if (!x) return false
        if (/^[0-9a-f]{32}$/i.test(x)) return true
        if (/^[0-9a-f]{40}$/i.test(x)) return true
        if (/^[0-9a-f]{64}$/i.test(x)) return true
        if (/^(sha1|sha256|md5):[0-9a-f]{16,64}$/i.test(x)) return true
        return false
      }

      function normHashish(s) {
        const x = String(s || "").trim()
        if (!x) return ""
        const m = x.match(/^(sha1|sha256|md5):(.+)$/i)
        return (m && m[2] ? m[2] : x).toLowerCase()
      }

      function basenameOf(p) {
        const x = String(p || "").trim()
        if (!x) return ""
        const s = x.replaceAll("\\", "/")
        const parts = s.split("/")
        return (parts[parts.length - 1] || "").trim()
      }

      function stemOfFilename(fn) {
        const x = String(fn || "").trim()
        if (!x) return ""
        return x.replace(/\.[a-z0-9]{2,6}$/i, "")
      }

      function collectStringsFromValue(val) {
        const out = []
        const push = (v) => {
          if (v == null) return
          const s = String(v).trim()
          if (s) out.push(s)
        }
        if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
          push(val); return out
        }
        if (Array.isArray(val)) {
          for (const v of val) push(v)
          return out
        }
        if (val && typeof val === "object") {
          for (const v of Object.values(val)) {
            if (typeof v === "string") push(v)
          }
        }
        return out
      }

      function extractManifestEntries(manifestJson) {
        if (Array.isArray(manifestJson)) {
          return manifestJson.map((x, i) => [String(i), x])
        }
        if (!manifestJson || typeof manifestJson !== "object") return []
        const maybe = manifestJson.files || manifestJson.items || manifestJson.data || manifestJson.manifest
        if (maybe && typeof maybe === "object") {
          return Object.entries(maybe)
        }
        return Object.entries(manifestJson)
      }

      function normalizeKey(s) {
        return String(s ?? "")
          .toLowerCase()
          .replace(/%[0-9a-f]{2}/gi, (m) => m.toUpperCase())
          .replace(/["'`´׳״]/g, "")
          .replace(/[‐-‒–—―]/g, "-")
          .replace(/[\u200B-\u200D\uFEFF]/g, "")
          .replace(/\s+/g, " ")
          .trim()
      }

      async function buildManifestMaps(manifestJson, onProgress) {
        const hashToPath = new Map()
        const baseToPath = new Map()
        const stemToPath = new Map()
        const baseNormToPath = new Map()
        const stemNormToPath = new Map()
        const baseNormToPaths = new Map()
        const stemNormToPaths = new Map()

        const putUnique = (map, key, path) => {
          if (!key) return
          if (!map.has(key)) map.set(key, path)
          else if (map.get(key) !== path) map.set(key, "")
        }
        const addMulti = (map, key, path) => {
          if (!key) return
          if (!map.has(key)) map.set(key, [])
          const arr = map.get(key)
          if (!Array.isArray(arr)) return
          if (arr.includes(path)) return
          // לא לאגור יותר מדי (מספיק לאבחון)
          if (arr.length < 12) arr.push(path)
        }

        const entries = extractManifestEntries(manifestJson)
        const total = entries.length

        for (let i = 0; i < total; i++) {
          const [k, vRaw] = entries[i]
          const kStr = String(k || "").trim()
          const vStrings = collectStringsFromValue(vRaw)

          let path = ""
          if (looksLikePath(kStr)) path = kStr
          else {
            for (const s of vStrings) {
              if (looksLikePath(s)) { path = s; break }
            }
          }

          if (path) {
            const b = basenameOf(path).toLowerCase()
            const st = stemOfFilename(b).toLowerCase()
            if (b && !baseToPath.has(b)) baseToPath.set(b, path)
            if (st && !stemToPath.has(st)) stemToPath.set(st, path)
            putUnique(baseNormToPath, normalizeKey(b), path)
            addMulti(baseNormToPaths, normalizeKey(b), path)
            putUnique(stemNormToPath, normalizeKey(st), path)
            addMulti(stemNormToPaths, normalizeKey(st), path)

            if (looksLikeHashish(kStr)) {
              const hk = normHashish(kStr)
              if (hk && !hashToPath.has(hk)) hashToPath.set(hk, path)
            }
            for (const s of vStrings) {
              if (looksLikeHashish(s)) {
                const hv = normHashish(s)
                if (hv && !hashToPath.has(hv)) hashToPath.set(hv, path)
              }
              const bb = basenameOf(s).toLowerCase()
              const sst = stemOfFilename(bb).toLowerCase()
              if (bb && !baseToPath.has(bb)) baseToPath.set(bb, path)
              if (sst && !stemToPath.has(sst)) stemToPath.set(sst, path)
              putUnique(baseNormToPath, normalizeKey(bb), path)
              addMulti(baseNormToPaths, normalizeKey(bb), path)
              putUnique(stemNormToPath, normalizeKey(sst), path)
              addMulti(stemNormToPaths, normalizeKey(sst), path)
            }
          }

          if (i % 5000 === 0) {
            if (onProgress) onProgress(i, total)
            await tick()
          }
        }

        if (onProgress) onProgress(total, total)
        return { hashToPath, baseToPath, stemToPath, baseNormToPath, stemNormToPath, baseNormToPaths, stemNormToPaths }
      }

      function pathFromItemUsingMaps(item, maps) {
        if (looksLikePath(item.path)) return item.path

        const strings = deepCollectStrings(item._raw, 5, 220)

        for (const s of strings) {
          if (!looksLikeHashish(s)) continue
          const h = normHashish(s)
          if (h && maps.hashToPath.has(h)) return maps.hashToPath.get(h)
        }

        for (const s of strings) {
          const b = basenameOf(s).toLowerCase()
          if (b && maps.baseToPath.has(b)) return maps.baseToPath.get(b)
        }

        for (const s of strings) {
          const b = basenameOf(s).toLowerCase()
          const st = stemOfFilename(b).toLowerCase()
          if (st && maps.stemToPath.has(st)) return maps.stemToPath.get(st)
        }

        // התאמה רופפת: מתעלמים ממרכאות/פיסוק/קידודים שונים (רק אם חד-משמעי ב־manifest)
        for (const s of strings) {
          const b0 = basenameOf(s)
          const nb = normalizeKey(b0)
          if (nb && maps.baseNormToPath && maps.baseNormToPath.has(nb)) {
            const p = maps.baseNormToPath.get(nb)
            if (p) return p
          }
        }

        for (const s of strings) {
          const b0 = basenameOf(s)
          const st0 = stemOfFilename(b0)
          const ns = normalizeKey(st0)
          if (ns && maps.stemNormToPath && maps.stemNormToPath.has(ns)) {
            const p = maps.stemNormToPath.get(ns)
            if (p) return p
          }
        }

        // ניסיון אחרון: התאמה לפי כותרת (רק אם חד-משמעי)
        const nt = normalizeKey(item.title || "")
        if (nt && maps.stemNormToPath && maps.stemNormToPath.has(nt)) {
          const p = maps.stemNormToPath.get(nt)
          if (p) return p
        }

        return ""
      }

      function normForSearch(s) {
        return String(s ?? "")
          .toLowerCase()
          .replace(/[\u0590-\u05FF]/g, (ch) => ch) // שומר עברית; רק מבטיח toLowerCase
          .replace(/\s+/g, " ")
          .trim()
      }

      function buildSearchField(it) {
        const parts = [it.title, it.author, it.path, it.id, it._key]
        return normForSearch(parts.filter(Boolean).join(" | "))
      }

      function compactItemForStorage(it) {
        return {
          title: it.title || "",
          author: it.author || "",
          path: it.path || "",
          id: it.id || "",
          q: it.q || "",
          cat: it.cat || [],
        }
      }

      function hydrateItemFromStorage(it) {
        const o = it && typeof it === "object" ? it : {}
        return {
          title: String(o.title || "").trim(),
          author: String(o.author || "").trim(),
          path: String(o.path || "").trim(),
          id: String(o.id || "").trim(),
          q: String(o.q || "").trim(),
          cat: Array.isArray(o.cat) ? o.cat : []
        }
      }

      async function refreshCatalog(force) {
        const btn = document.getElementById("btnLoad")
        btn.disabled = true

        try {
          if (force) {
            setStatus("כופה רענון קטלוג...")
            await idbDel(CATALOG_KEY)
          }

          // ניסיון טעינה מהמטמון (IndexedDB)
          const cached = await idbGet(CATALOG_KEY)
          if (cached && cached.items && cached.items.length && !force) {
            const age = Date.now() - (cached.builtAt || 0)
            items = cached.items.map(hydrateItemFromStorage)
            setStatus(`נטען מהמטמון (עודכן לפני ${Math.round(age / 60000)} דקות)`)
            afterCatalogLoaded()
            // רענון שקט אם עבר זמן רב
            if (age > MAX_CATALOG_AGE_MS) {
              backgroundRefresh()
            }
            return
          }

          // בנייה מחדש (לוגיקה זהה לקוד הישן)
          setStatus("טוען metadata...")
          const metaJson = await fetchJsonAny([
            "/api/metadata",
            "/lib/metadata.json"
          ])

          const rawMetaItems = extractBestCollection(metaJson)
          if (!rawMetaItems.length) {
            setStatus("נטען metadata אבל לא זוהתה רשימה")
            alert("לא הצלחתי לחלץ רשימת פריטים מתוך metadata.json")
            return
          }

          setStatus(`מעבד metadata... (0/${rawMetaItems.length})`)
          const normalized = []
          for (let i = 0; i < rawMetaItems.length; i++) {
            normalized.push(normalizeMetaItem(rawMetaItems[i]))
            if (i % 3000 === 0) {
              setStatus(`מעבד metadata... (${i}/${rawMetaItems.length})`)
              await tick()
            }
          }
          setStatus(`מעבד metadata... (${rawMetaItems.length}/${rawMetaItems.length})`)

          setStatus("טוען files_manifest...")
          const manifestJson = await fetchJsonAny([
            "/api/manifest",
            "/lib/files_manifest.json"
          ])

          setStatus("בונה מפות מה־manifest...")
          const maps = await buildManifestMaps(manifestJson, (done, total) => {
            setStatus(`בונה מפות מה־manifest... (${done}/${total})`)
          })
          lastMaps = maps

          setStatus("מצמיד נתיבים (path) לפי ה־manifest...")
          let fixed = 0
          for (let i = 0; i < normalized.length; i++) {
            const it = normalized[i]
            const p = pathFromItemUsingMaps(it, maps)
            if (p && p !== it.path) { it.path = p; fixed++ }
            if (i % 3000 === 0) {
              setStatus(`מצמיד נתיבים... (${i}/${normalized.length})`)
              await tick()
            }
          }

          setStatus(`מצמיד נתיבים... (${normalized.length}/${normalized.length})`)

          // בניית שדה חיפוש + קטגוריות (לפי נתיב תיקיות)
          const finalItems = []
          for (let i = 0; i < normalized.length; i++) {
            const it = normalized[i]
            const cat = computeCategoryFromPath(it.path)
            const q = buildSearchField(it)
            finalItems.push({
              title: it.title,
              author: it.author,
              path: it.path,
              id: it.id,
              _key: it._key,
              q,
              cat
            })
            if (i % 5000 === 0) await tick()
          }

          items = finalItems

          // שמירה במטמון (רק שדות דחוסים)
          try {
            const payload = {
              builtAt: Date.now(),
              items: items.map(compactItemForStorage),
              stats: {
                total: items.length,
                withPath: items.filter(x => x.path).length,
                fixed
              }
            }
            await idbSet(CATALOG_KEY, payload)
            setStatus(`נטען + נשמר במטמון | סה"כ: ${payload.stats.total} | עם קובץ: ${payload.stats.withPath} | הושלמו נתיבים: ${fixed}`)
          } catch (e) {
            console.warn("Cache save failed:", e)
            setStatus(`נטען (ללא שמירת מטמון) | סה"כ: ${items.length} | עם קובץ: ${items.filter(x => x.path).length}`)
          }

          afterCatalogLoaded()
        } catch (e) {
          console.error(e)
          setStatus("שגיאה בטעינת הקטלוג")
          alert("שגיאה: " + (e && e.message ? e.message : e))
        } finally {
          btn.disabled = false
        }
      }

      function backgroundRefresh() {
        // רענון שקט (לא שובר מסך) — אם נכשל, מתעלמים
        refreshCatalog(true).catch(() => {})
      }

      // =========================
      // Search / render
      // =========================
      let searchDebounce = null
      function onSearchInput() {
        clearTimeout(searchDebounce)
        searchDebounce = setTimeout(applySearch, 120)
      }

      function clearQuery() {
        document.getElementById("q").value = ""
        applySearch()
      }

      function downloadMissing() {
        const miss = items.filter(x => !x.path).map(x => `${x.title}\t${x.author}\t${x.id || x._key || ""}`)
        const blob = new Blob([miss.join("\n")], { type: "text/plain;charset=utf-8" })
        const a = document.createElement("a")
        a.href = URL.createObjectURL(blob)
        a.download = "missing_paths.tsv"
        a.click()
      }

      function afterCatalogLoaded() {
        renderCursor = 0
        categoryRoot = buildCategoryTree(items.filter(x => x.path))
        // פותחים כמה רמות ראשונות כברירת מחדל (כדי שתהיה תחושת קטגוריות)
        expandedCategoryKeys = new Set()
        for (const child of categoryRoot.children.values()) {
          expandedCategoryKeys.add(catKey(child.segs))
        }
        renderCategories()
        applySearch()
      }

      function matchesSelectedCategory(it) {
        if (!selectedCategorySegs || !selectedCategorySegs.length) return true
        const segs = Array.isArray(it.cat) ? it.cat : []
        if (segs.length < selectedCategorySegs.length) return false
        for (let i = 0; i < selectedCategorySegs.length; i++) {
          if (String(segs[i]) !== String(selectedCategorySegs[i])) return false
        }
        return true
      }

      function applySearch() {
        const q = normForSearch(document.getElementById("q").value || "")
        const fileMode = document.getElementById("fileMode").value
        const searchAllCats = document.getElementById("searchAllCats").checked

        let list = items

        const hasCat = Array.isArray(selectedCategorySegs) && selectedCategorySegs.length
        // ניווט קטגוריות תמיד מסנן את הרשימה; אופציית "חיפוש בכל הקטגוריות" משפיעה רק כאשר יש מחרוזת חיפוש.
        if (hasCat && !(q && searchAllCats)) {
          list = list.filter(matchesSelectedCategory)
        }

        if (fileMode === "with") list = list.filter(x => !!x.path)
        if (fileMode === "without") list = list.filter(x => !x.path)

        if (q) {
          list = list.filter(x => (x.q || "").includes(q))
        }

        if (searchAllCats) {
          // אם החיפוש בכל הקטגוריות, נשאיר את רשימת התוצאות גלובלית
        } else {
          // אם החיפוש מוגבל לקטגוריה נבחרת, כבר סיננו
        }

        currentList = list
        renderCursor = 0

        const hint = []
        if (selectedCategorySegs.length) hint.push("קטגוריה: " + selectedCategorySegs.join(" / "))
        if (q) hint.push("חיפוש: " + q)
        if (q && searchAllCats && selectedCategorySegs.length) hint.push("חיפוש בכל הקטגוריות")
        hint.push("סה\"כ: " + currentList.length)
        document.getElementById("scopeHint").textContent = hint.join(" | ")

        renderNextPage(true)
      }

      function renderNextPage(clear) {
        const box = document.getElementById("results")
        if (clear) box.innerHTML = ""

        const slice = currentList.slice(renderCursor, renderCursor + PAGE_SIZE)
        renderCursor += slice.length

        const frag = document.createDocumentFragment()
        for (const it of slice) {
          frag.appendChild(renderCard(it))
        }
        box.appendChild(frag)

        // כפתור "טען עוד" בסוף (במקום אינסוף-גלילה)
        if (renderCursor < currentList.length) {
          const btn = document.createElement("button")
          btn.textContent = `טען עוד (${renderCursor}/${currentList.length})`
          btn.onclick = () => {
            btn.remove()
            renderNextPage(false)
          }
          box.appendChild(btn)
        }
      }

      function renderCard(it) {
        const div = document.createElement("div")
        div.className = "card"
        div.onclick = () => {
          if (!it.path) return alert("לפריט הזה אין נתיב קובץ")
          viewInline(it.path)
        }

        const title = document.createElement("div")
        title.className = "title"
        title.textContent = it.title || "ללא כותרת"
        div.appendChild(title)

        const meta = document.createElement("div")
        meta.className = "meta"
        meta.innerHTML =
          `<span>${escapeHtml(it.author || "—")}</span>` +
          (it.cat && it.cat.length ? ` | <span>${escapeHtml(it.cat.join(" / "))}</span>` : "")
        div.appendChild(meta)


        const actions = document.createElement("div")
        actions.className = "actions"

        const b1 = document.createElement("button")
        b1.className = "btnSmall"
        b1.textContent = "פתח בטאב"
        b1.onclick = (e) => { e.stopPropagation(); openInNewTab(it.path) }
        actions.appendChild(b1)


        div.appendChild(actions)
        return div
      }

      // =========================
      // Categories
      // =========================
      function computeCategoryFromPath(p) {
        const x = String(p || "").trim()
        if (!x) return []
        if (x.startsWith("http://") || x.startsWith("https://")) return []
        const parts = x.replaceAll("\\", "/").split("/").filter(Boolean)
        if (parts.length <= 1) return []
        // אם יש "ספרים" בנתיב, נתחיל ממנו כדי לא להציג פרפיקסים טכניים (כמו DictaToOtzaria וכו')
        const booksIdx = parts.indexOf("ספרים")
        const start = (booksIdx >= 0 && booksIdx < parts.length - 1) ? booksIdx + 1 : 0
        // קטגוריה = כל התיקיות (ללא שם הקובץ)
        return parts.slice(start, parts.length - 1)
      }

      function buildCategoryTree(list) {
        const root = { name: "", segs: [], count: 0, children: new Map() }
        function getChild(parent, name, segs) {
          if (!parent.children.has(name)) {
            parent.children.set(name, { name, segs, count: 0, children: new Map() })
          }
          return parent.children.get(name)
        }

        for (const it of list) {
          if (!it.path) continue
          const segs = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)
          let node = root
          node.count++
          for (let i = 0; i < segs.length; i++) {
            const s = String(segs[i] || "").trim()
            if (!s) continue
            const nextSegs = segs.slice(0, i + 1)
            node = getChild(node, s, nextSegs)
            node.count++
          }
        }
        return root
      }

      function catKey(segs) {
        return (segs || []).join("/")
      }

      function toggleExpanded(segs) {
        const k = catKey(segs)
        if (expandedCategoryKeys.has(k)) expandedCategoryKeys.delete(k)
        else expandedCategoryKeys.add(k)
      }

      function selectCategory(segs) {
        selectedCategorySegs = Array.isArray(segs) ? segs : []
        // פותחים אוטומטית את הדרך עד הצומת שנבחר
        let acc = []
        for (const s of selectedCategorySegs) {
          acc = [...acc, s]
          expandedCategoryKeys.add(catKey(acc))
        }
        applySearch()
        scrollToResults()
        renderCategories()
      }

      function clearCategory() {
        selectedCategorySegs = []
        applySearch()
        renderCategories()
      }

      function renderCategories() {
        const box = document.getElementById("cats")
        if (!categoryRoot) {
          box.textContent = "—"
          return
        }
        box.innerHTML = ""
        const frag = document.createDocumentFragment()

        const children = Array.from(categoryRoot.children.values())
          .sort((a, b) => a.name.localeCompare(b.name, "he"))

        if (!children.length) {
          box.textContent = "אין קטגוריות (או שאין נתיבים)"
          return
        }

        function renderNode(node, depth) {
          const row = document.createElement("div")
          row.className = "catRow"
          row.style.paddingRight = (depth * 10) + "px"

          const hasKids = node.children && node.children.size
          const isOpen = expandedCategoryKeys.has(catKey(node.segs))

          const toggle = document.createElement("button")
          toggle.className = "btnSmall catToggle"
          toggle.textContent = hasKids ? (isOpen ? "▾" : "▸") : "•"
          toggle.disabled = !hasKids
          toggle.onclick = (e) => {
            e.stopPropagation()
            toggleExpanded(node.segs)
            renderCategories()
          }
          row.appendChild(toggle)

          const btn = document.createElement("button")
          btn.className = "catBtn btnSmall" + (catKey(node.segs) === catKey(selectedCategorySegs) ? " selected" : "")
          btn.innerHTML = `${escapeHtml(node.name)} <span class="muted">(${node.count})</span>`
          btn.onclick = () => selectCategory(node.segs)
          row.appendChild(btn)

          frag.appendChild(row)

          if (hasKids && isOpen) {
            const kids = Array.from(node.children.values()).sort((a, b) => a.name.localeCompare(b.name, "he"))
            for (const k of kids) renderNode(k, depth + 1)
          }
        }

        for (const c of children) renderNode(c, 0)

        box.appendChild(frag)
      }

      // =========================
      // Encoding helpers (percent-preserving)
      // =========================
      function encodePreservePct(s, encoderFn) {
        const str = String(s ?? "")
        // Preserve existing %XX sequences to avoid double encoding
        return str.replace(/%[0-9A-Fa-f]{2}/g, (m) => `__PCT__${m.slice(1)}__`).split("__PCT__").map((chunk) => {
          const mm = chunk.match(/^([0-9A-Fa-f]{2})__(.*)$/)
          if (mm) return "%" + mm[1].toUpperCase() + encoderFn(mm[2])
          return encoderFn(chunk)
        }).join("")
      }

      function encodeURIComponentStrict(s) {
        // encodeURIComponent but also encodes !'()* which RFC3986 suggests
        return encodeURIComponent(String(s ?? "")).replace(/[!'()*]/g, (c) => "%" + c.charCodeAt(0).toString(16).toUpperCase())
      }

      // =========================
      // Init
      // =========================
      refreshCatalog(false)

    </script>
  </body>
</html>
