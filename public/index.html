<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ספרייה - קטלוג</title>
    <style>
      :root{
        --bg: #ffffff;
        --muted: #666;
        --border: #e6e6e6;
        --card: #ffffff;
        --shadow: 0 1px 2px rgba(0,0,0,.06);
        --radius: 12px;
        --sidebarW: 320px;
      }

      body{
        font-family: system-ui, Arial;
        margin: 0;
        background: var(--bg);
      }

      .header{
        position: sticky;
        top: 0;
        z-index: 10;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
        padding: 14px 16px;
      }

      .hTitle{
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      h2{ margin: 0; font-size: 20px; }
      .muted{ color: var(--muted); font-size: 13px; }

      .toolbar{
        margin-top: 10px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      .pill{
        padding: 4px 8px;
        border: 1px solid var(--border);
        border-radius: 999px;
        font-size: 12px;
        color: #444;
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }

      input[type="text"]{
        width: 100%;
        padding: 10px;
        font-size: 16px;
        border: 1px solid var(--border);
        border-radius: 10px;
      }

      button{
        padding: 10px 12px;
        font-size: 14px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: #fff;
        cursor: pointer;
      }
      button:disabled{ opacity: .6; cursor: not-allowed; }

      .btnSmall{
        padding: 6px 10px;
        font-size: 13px;
        border-radius: 10px;
      }

      .layout{
        display: grid;
        grid-template-columns: var(--sidebarW) 1fr;
        gap: 16px;
        padding: 16px;
        align-items: start;
      }

      @media (max-width: 980px){
        .layout{ grid-template-columns: 1fr; }
        .sidebar{ position: static; }
      }

      .sidebar{
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 10px;
        position: sticky;
        top: 132px;
        max-height: calc(100vh - 160px);
        overflow: auto;
        background: var(--card);
      }

      .sideTop{
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 4px 6px 10px 6px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 8px;
      }

      .sideTitle{ font-weight: 700; }

      .catRow{
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 0;
      }

      .catToggle{
        width: 28px;
        padding: 6px 0;
        text-align: center;
      }

      .catBtn{
        flex: 1;
        text-align: right;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid transparent;
        background: transparent;
      }
      .catBtn:hover{ border-color: var(--border); background: #fafafa; }
      .catBtn.selected{ border-color: #cfe1ff; background: #f4f8ff; }

      .main{
        min-width: 0;
      }

      .resultsHeader{
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
      }

      .grid{
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin-top: 10px;
      }

      .card{
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 10px;
        background: var(--card);
        box-shadow: var(--shadow);
        cursor: pointer;
      }

      .title{ font-weight: 700; }
      .meta{ margin-top: 6px; color: #444; font-size: 14px; }
      .path{ margin-top: 6px; color: #888; font-size: 12px; direction: ltr; text-align: left; word-break: break-all; }
      .actions{ display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }

      a{ color: #0b57d0; }

      /* Viewer (modal) */
      .viewerModal{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.35);
        display: none;
        z-index: 1000;
        padding: 18px;
      }
      .viewerModal.show{ display: block; }
      .viewerCard{
        max-width: 1200px;
        margin: 0 auto;
        height: calc(100vh - 36px);
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 12px 42px rgba(0,0,0,.24);
        border: 1px solid var(--border);
        display: grid;
        grid-template-rows: auto 1fr;
        overflow: hidden;
      }
      .viewerTop{
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 12px;
        border-bottom: 1px solid var(--border);
      }
      .viewerTop .muted{ font-size: 12px; }
      iframe{
        width: 100%;
        height: 100%;
        border: 0;
      }
    </style>
  </head>

  <body>
    <div class="header">
      <div class="hTitle">
        <div>
          <h2>ספרייה — קטלוג</h2>
          <div class="muted">
            קטגוריות נבנות לפי נתיבי התיקיות. החיפוש עובד על כל הקטלוג (גם פריטים שעוד לא הוצגו במסך).
          </div>
        </div>
        <span id="status" class="pill">לא נטען</span>
      </div>

      <div class="toolbar">
        <button id="btnLoad" onclick="refreshCatalog(true)">כפה רענון</button>
        <button class="btnSmall" onclick="scrollToResults()">לתוצאות</button>
        <button class="btnSmall" onclick="openPathInNewTab()">פתח נתיב ידני בטאב</button>
        <button class="btnSmall" onclick="openPathInline()">צפה בנתיב ידני כאן</button>
        <button class="btnSmall" onclick="ping()">בדיקה: /api/ping</button>

        <label class="pill">
          מצב תצוגה:
          <select id="fileMode" onchange="applySearch()">
            <option value="with" selected>רק עם קובץ</option>
            <option value="without">רק בלי קובץ</option>
            <option value="all">הכל</option>
          </select>
        </label>

        <button class="btnSmall" onclick="clearQuery()">נקה חיפוש</button>
        <button class="btnSmall" onclick="downloadMissing()">הורד רשימת חסרים</button>

        <label class="pill">
          <input id="searchAllCats" type="checkbox" onchange="applySearch()" checked />
          חיפוש בכל הקטגוריות
        </label>
      </div>

      <div class="actions">
        <input id="q" type="text" placeholder="חיפוש (כותרת/מחבר/נתיב)..." oninput="onSearchInput()" />
      </div>

      <div class="actions">
        <input id="path" type="text" placeholder="נתיב ידני בתוך הריפו (למשל: .../file.pdf)" />
        <div class="muted">
          קישור נוכחי: <a id="link" href="#" target="_blank" rel="noreferrer">—</a>
        </div>
      </div>
    </div>

    <div class="layout">
      <aside class="sidebar">
        <div class="sideTop">
          <div class="sideTitle">קטגוריות</div>
          <button class="btnSmall" onclick="clearCategory()">הכל</button>
        </div>
        <div id="cats" class="muted">—</div>
      </aside>

      <main class="main">
        <div class="resultsHeader">
          <h3 id="resultsTitle" style="margin:0;">תוצאות</h3>
          <div class="muted" id="scopeHint"></div>
        </div>
        <div id="results" class="grid"></div>
      </main>
    </div>

    <div id="viewerWrap" class="viewerModal" onclick="onViewerBackdrop(event)">
      <div class="viewerCard">
        <div class="viewerTop">
          <div>
            <div style="font-weight:700;">צפייה בתוך הדף</div>
            <div class="muted">אפשר לסגור עם ESC או קליק מחוץ לחלון.</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="btnSmall" onclick="openViewerInNewTab()">פתח בטאב</button>
            <button class="btnSmall" onclick="hideViewer()">סגור</button>
          </div>
        </div>
        <iframe id="viewer" title="viewer"></iframe>
      </div>
    </div>

    <script>
      // =========================
      // State
      // =========================
      let items = []
      let currentList = []
      let renderCursor = 0
      const PAGE_SIZE = 60

      let categoryRoot = null
      let selectedCategorySegs = []
      let expandedCategoryKeys = new Set()

      let lastViewerPath = ""

      // Cache settings
      const IDB_DB = "otzaria_catalog"
      const IDB_STORE = "kv"
      const CATALOG_KEY = "catalog_v1"
      const MAX_CATALOG_AGE_MS = 12 * 60 * 60 * 1000 // 12 שעות

      // =========================
      // UI helpers
      // =========================
      function setStatus(text) {
        document.getElementById("status").textContent = text
      }

      function tick() {
        return new Promise(r => setTimeout(r, 0))
      }

      function scrollToResults() {
        document.getElementById("resultsTitle").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function escapeHtml(s) {
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;")
      }

      function encodePath(path) {
        return String(path)
          .split("/")
          .filter(Boolean)
          .map(encodeURIComponent)
          .join("/")
      }

      function libUrl(pathOrUrl) {
        const v = String(pathOrUrl || "").trim()
        if (!v) return ""
        if (v.startsWith("http://") || v.startsWith("https://")) return v
        return "/lib/" + encodePath(v)
      }

      function refreshLink(url) {
        const a = document.getElementById("link")
        a.textContent = url || "—"
        a.href = url || "#"
      }

      function openInNewTab(path) {
        const p = String(path || "").trim()
        if (!p) return
        const viewer = "/view?path=" + encodeURIComponent(p)
        refreshLink(viewer)
        window.open(viewer, "_blank", "noopener,noreferrer")
      }

      function viewInline(path) {
        const p = String(path || "").trim()
        if (!p) return
        lastViewerPath = p
        const viewerUrl = "/view?path=" + encodeURIComponent(p)
        refreshLink(viewerUrl)
        showViewer(viewerUrl)
      }

      function showViewer(viewerUrl) {
        const wrap = document.getElementById("viewerWrap")
        wrap.classList.add("show")
        document.getElementById("viewer").src = viewerUrl
      }

      function hideViewer() {
        const wrap = document.getElementById("viewerWrap")
        wrap.classList.remove("show")
        const iframe = document.getElementById("viewer")
        iframe.src = "about:blank"
      }

      function onViewerBackdrop(e) {
        if (e.target && e.target.id === "viewerWrap") hideViewer()
      }

      function openViewerInNewTab() {
        if (!lastViewerPath) return
        openInNewTab(lastViewerPath)
      }

      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") hideViewer()
      })

      function openPathInNewTab() {
        const p = document.getElementById("path").value.trim()
        if (!p) return alert("הזן נתיב ידני")
        openInNewTab(p)
      }

      function openPathInline() {
        const p = document.getElementById("path").value.trim()
        if (!p) return alert("הזן נתיב ידני")
        viewInline(p)
      }

      async function ping() {
        try {
          const r = await fetch("/api/ping", { cache: "no-store" })
          alert("ping: " + r.status + " " + (await r.text()))
        } catch (e) {
          alert("ping error: " + (e && e.message ? e.message : e))
        }
      }

      // =========================
      // IndexedDB (persistent cache)
      // =========================
      function openDb() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(IDB_DB, 1)
          req.onupgradeneeded = () => {
            const db = req.result
            if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE)
          }
          req.onsuccess = () => resolve(req.result)
          req.onerror = () => reject(req.error)
        })
      }

      async function idbGet(key) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly")
          const store = tx.objectStore(IDB_STORE)
          const r = store.get(key)
          r.onsuccess = () => resolve(r.result)
          r.onerror = () => reject(r.error)
        })
      }

      async function idbSet(key, val) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite")
          const store = tx.objectStore(IDB_STORE)
          const r = store.put(val, key)
          r.onsuccess = () => resolve(true)
          r.onerror = () => reject(r.error)
        })
      }

      async function idbDel(key) {
        const db = await openDb()
        return new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite")
          const store = tx.objectStore(IDB_STORE)
          const r = store.delete(key)
          r.onsuccess = () => resolve(true)
          r.onerror = () => reject(r.error)
        })
      }

      // =========================
      // Catalog loading (keeps old retrieval logic)
      // =========================
      async function fetchJsonAny(urls) {
        let lastErr = null
        for (const u of urls) {
          try {
            const r = await fetch(u, { cache: "no-store" })
            if (r.ok) return await r.json()
            lastErr = new Error(`${u} -> HTTP ${r.status}`)
          } catch (e) {
            lastErr = e
          }
        }
        throw lastErr || new Error("fetchJsonAny failed")
      }

      function objectToArrayMap(obj) {
        const arr = []
        for (const [k, v] of Object.entries(obj || {})) {
          if (v && typeof v === "object") arr.push({ ...v, _key: k })
          else arr.push({ title: String(v ?? "").trim(), _key: k })
        }
        return arr
      }

      function extractBestCollection(json) {
        if (Array.isArray(json)) return json
        if (!json || typeof json !== "object") return []

        let bestArr = null
        let bestLen = -1
        for (const v of Object.values(json)) {
          if (Array.isArray(v) && v.length > bestLen) {
            bestArr = v
            bestLen = v.length
          }
        }
        if (bestArr) return bestArr

        const containerKeys = ["items", "books", "data", "metadata", "list"]
        for (const k of containerKeys) {
          const v = json[k]
          if (Array.isArray(v)) return v
          if (v && typeof v === "object") return objectToArrayMap(v)
        }

        const keys = Object.keys(json)
        if (keys.length) {
          const sampleN = Math.min(keys.length, 500)
          let score = 0
          for (let i = 0; i < sampleN; i++) {
            const v = json[keys[i]]
            if (v && typeof v === "object") score++
          }
          if (score >= Math.floor(sampleN * 0.6)) {
            return objectToArrayMap(json)
          }
        }

        return []
      }

      function getAny(o, keys) {
        for (const k of keys) {
          if (o && Object.prototype.hasOwnProperty.call(o, k)) return o[k]
        }
        return null
      }

      function normalizeMetaItem(x) {
        const o = (x && typeof x === "object") ? x : {}
        const titleVal = getAny(o, ["title", "name", "he_title", "heb_title", "book", "display", "caption"]) ?? ""
        const authorVal = getAny(o, ["author", "authors", "by", "creator", "writer"]) ?? ""
        const pathVal = getAny(o, ["path", "file", "filename", "relpath", "uri", "url", "href"]) ?? ""
        const idVal = getAny(o, ["id", "book_id", "bookId", "...", "hash", "sha", "sha1", "sha256", "md5"]) ?? (o._key ?? "")

        const title = Array.isArray(titleVal) ? titleVal.join(" ") : titleVal
        const author = Array.isArray(authorVal) ? authorVal.join(", ") : authorVal
        const path = Array.isArray(pathVal) ? pathVal[0] : pathVal

        return {
          title: String(title || "").trim(),
          author: String(author || "").trim(),
          path: String(path || "").trim(),
          id: String(idVal ?? "").trim(),
          _key: String(o._key || "").trim(),
          _raw: o
        }
      }

      function deepCollectStrings(root, maxDepth = 5, maxItems = 250) {
        const out = []
        const seen = new Set()

        function push(v) {
          const s = String(v || "").trim()
          if (!s) return
          if (s.length > 500) return
          if (seen.has(s)) return
          seen.add(s)
          out.push(s)
        }

        function walk(node, depth) {
          if (out.length >= maxItems) return
          if (depth > maxDepth) return
          if (node == null) return

          const t = typeof node
          if (t === "string" || t === "number" || t === "boolean") {
            push(node)
            return
          }
          if (Array.isArray(node)) {
            for (let i = 0; i < node.length; i++) {
              walk(node[i], depth + 1)
              if (out.length >= maxItems) return
            }
            return
          }
          if (t === "object") {
            for (const [k, v] of Object.entries(node)) {
              push(k)
              walk(v, depth + 1)
              if (out.length >= maxItems) return
            }
          }
        }

        walk(root, 0)
        return out
      }

      function looksLikePath(s) {
        const x = String(s || "").trim()
        if (!x) return false
        if (x.startsWith("http://") || x.startsWith("https://")) return true
        if (x.includes("/")) return true
        if (x.includes("\\")) return true
        if (x.match(/\.[a-z0-9]{2,6}$/i)) return true
        return false
      }

      function looksLikeHashish(s) {
        const x = String(s || "").trim()
        if (!x) return false
        if (/^[0-9a-f]{32}$/i.test(x)) return true
        if (/^[0-9a-f]{40}$/i.test(x)) return true
        if (/^[0-9a-f]{64}$/i.test(x)) return true
        if (/^(sha1|sha256|md5):[0-9a-f]{16,64}$/i.test(x)) return true
        return false
      }

      function normHashish(s) {
        const x = String(s || "").trim()
        if (!x) return ""
        const m = x.match(/^(sha1|sha256|md5):(.+)$/i)
        return (m && m[2] ? m[2] : x).toLowerCase()
      }

      function basenameOf(p) {
        const x = String(p || "").trim()
        if (!x) return ""
        const s = x.replaceAll("\\", "/")
        const parts = s.split("/")
        return (parts[parts.length - 1] || "").trim()
      }

      function stemOfFilename(fn) {
        const x = String(fn || "").trim()
        if (!x) return ""
        return x.replace(/\.[a-z0-9]{2,6}$/i, "")
      }

      function collectStringsFromValue(val) {
        const out = []
        const push = (v) => {
          if (v == null) return
          const s = String(v).trim()
          if (s) out.push(s)
        }
        if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
          push(val); return out
        }
        if (Array.isArray(val)) {
          for (const v of val) push(v)
          return out
        }
        if (val && typeof val === "object") {
          for (const v of Object.values(val)) {
            if (typeof v === "string") push(v)
          }
        }
        return out
      }

      function extractManifestEntries(manifestJson) {
        if (Array.isArray(manifestJson)) {
          return manifestJson.map((x, i) => [String(i), x])
        }
        if (!manifestJson || typeof manifestJson !== "object") return []
        const maybe = manifestJson.files || manifestJson.items || manifestJson.data || manifestJson.manifest
        if (maybe && typeof maybe === "object") {
          return Object.entries(maybe)
        }
        return Object.entries(manifestJson)
      }

      async function buildManifestMaps(manifestJson, onProgress) {
        const hashToPath = new Map()
        const baseToPath = new Map()
        const stemToPath = new Map()
        const baseNormToPath = new Map()
        const stemNormToPath = new Map()

        const putUnique = (map, key, path) => {
          if (!key) return
          if (!map.has(key)) map.set(key, path)
          else if (map.get(key) !== path) map.set(key, "")
        }
        const entries = extractManifestEntries(manifestJson)
        const total = entries.length

        for (let i = 0; i < total; i++) {
          const [k, vRaw] = entries[i]
          const kStr = String(k || "").trim()
          const vStrings = collectStringsFromValue(vRaw)

          let path = ""
          if (looksLikePath(kStr)) path = kStr
          else {
            for (const s of vStrings) {
              if (looksLikePath(s)) { path = s; break }
            }
          }

          if (path) {
            const b = basenameOf(path).toLowerCase()
            const st = stemOfFilename(b).toLowerCase()
            if (b && !baseToPath.has(b)) baseToPath.set(b, path)
            if (st && !stemToPath.has(st)) stemToPath.set(st, path)
            putUnique(baseNormToPath, normalizeKey(b), path)
            putUnique(stemNormToPath, normalizeKey(st), path)

            if (looksLikeHashish(kStr)) {
              const hk = normHashish(kStr)
              if (hk && !hashToPath.has(hk)) hashToPath.set(hk, path)
            }
            for (const s of vStrings) {
              if (looksLikeHashish(s)) {
                const hv = normHashish(s)
                if (hv && !hashToPath.has(hv)) hashToPath.set(hv, path)
              }
              const bb = basenameOf(s).toLowerCase()
              const sst = stemOfFilename(bb).toLowerCase()
              if (bb && !baseToPath.has(bb)) baseToPath.set(bb, path)
              if (sst && !stemToPath.has(sst)) stemToPath.set(sst, path)
              putUnique(baseNormToPath, normalizeKey(bb), path)
              putUnique(stemNormToPath, normalizeKey(sst), path)
            }
          }

          if (i % 5000 === 0) {
            if (onProgress) onProgress(i, total)
            await tick()
          }
        }

        if (onProgress) onProgress(total, total)
        return { hashToPath, baseToPath, stemToPath, baseNormToPath, stemNormToPath }
      }

      function pathFromItemUsingMaps(item, maps) {
        if (looksLikePath(item.path)) return item.path

        const strings = deepCollectStrings(item._raw, 5, 220)

        for (const s of strings) {
          if (!looksLikeHashish(s)) continue
          const h = normHashish(s)
          if (h && maps.hashToPath.has(h)) return maps.hashToPath.get(h)
        }

        for (const s of strings) {
          const b = basenameOf(s).toLowerCase()
          if (b && maps.baseToPath.has(b)) return maps.baseToPath.get(b)
        }

        for (const s of strings) {
          const b = basenameOf(s).toLowerCase()
          const st = stemOfFilename(b).toLowerCase()
          if (st && maps.stemToPath.has(st)) return maps.stemToPath.get(st)
        }

        // התאמה רופפת: מתעלמים ממרכאות/פיסוק/קידודים שונים (רק אם חד-משמעי ב־manifest)
        for (const s of strings) {
          const b0 = basenameOf(s)
          const nb = normalizeKey(b0)
          if (nb && maps.baseNormToPath && maps.baseNormToPath.has(nb)) {
            const p = maps.baseNormToPath.get(nb)
            if (p) return p
          }
        }

        for (const s of strings) {
          const b0 = basenameOf(s)
          const st0 = stemOfFilename(b0)
          const ns = normalizeKey(st0)
          if (ns && maps.stemNormToPath && maps.stemNormToPath.has(ns)) {
            const p = maps.stemNormToPath.get(ns)
            if (p) return p
          }
        }

        // ניסיון אחרון: התאמה לפי כותרת (רק אם חד-משמעי)
        const nt = normalizeKey(item.title || "")
        if (nt && maps.stemNormToPath && maps.stemNormToPath.has(nt)) {
          const p = maps.stemNormToPath.get(nt)
          if (p) return p
        }

        return ""
      }

      function normForSearch(s) {
        return String(s ?? "")
          .toLowerCase()
          .replace(/[\u0590-\u05FF]/g, (ch) => ch) // שומר עברית; רק מבטיח toLowerCase
          .replace(/\s+/g, " ")
          .trim()
      }

      function buildSearchField(it) {
        const parts = [it.title, it.author, it.path, it.id, it._key]
        return normForSearch(parts.filter(Boolean).join(" | "))
      }

      function compactItemForStorage(it) {
        return {
          title: it.title || "",
          author: it.author || "",
          path: it.path || "",
          id: it.id || "",
          q: it.q || "",
          cat: it.cat || [],
        }
      }

      function hydrateItemFromStorage(it) {
        const o = it && typeof it === "object" ? it : {}
        return {
          title: String(o.title || "").trim(),
          author: String(o.author || "").trim(),
          path: String(o.path || "").trim(),
          id: String(o.id || "").trim(),
          q: String(o.q || "").trim(),
          cat: Array.isArray(o.cat) ? o.cat : []
        }
      }

      async function refreshCatalog(force) {
        const btn = document.getElementById("btnLoad")
        btn.disabled = true

        try {
          if (force) {
            setStatus("כופה רענון קטלוג...")
            await idbDel(CATALOG_KEY)
          }

          // ניסיון טעינה מהמטמון (IndexedDB)
          const cached = await idbGet(CATALOG_KEY)
          if (cached && cached.items && cached.items.length && !force) {
            const age = Date.now() - (cached.builtAt || 0)
            items = cached.items.map(hydrateItemFromStorage)
            setStatus(`נטען מהמטמון (עודכן לפני ${Math.round(age / 60000)} דקות)`)
            afterCatalogLoaded()
            // רענון שקט אם עבר זמן רב
            if (age > MAX_CATALOG_AGE_MS) {
              backgroundRefresh()
            }
            return
          }

          // בנייה מחדש (לוגיקה זהה לקוד הישן)
          setStatus("טוען metadata...")
          const metaJson = await fetchJsonAny([
            "/api/metadata",
            "/lib/metadata.json"
          ])

          const rawMetaItems = extractBestCollection(metaJson)
          if (!rawMetaItems.length) {
            setStatus("נטען metadata אבל לא זוהתה רשימה")
            alert("לא הצלחתי לחלץ רשימת פריטים מתוך metadata.json")
            return
          }

          setStatus(`מעבד metadata... (0/${rawMetaItems.length})`)
          const normalized = []
          for (let i = 0; i < rawMetaItems.length; i++) {
            normalized.push(normalizeMetaItem(rawMetaItems[i]))
            if (i % 3000 === 0) {
              setStatus(`מעבד metadata... (${i}/${rawMetaItems.length})`)
              await tick()
            }
          }
          setStatus(`מעבד metadata... (${rawMetaItems.length}/${rawMetaItems.length})`)

          setStatus("טוען files_manifest...")
          const manifestJson = await fetchJsonAny([
            "/api/manifest",
            "/lib/files_manifest.json"
          ])

          setStatus("בונה מפות מה־manifest...")
          const maps = await buildManifestMaps(manifestJson, (done, total) => {
            setStatus(`בונה מפות מה־manifest... (${done}/${total})`)
          })

          setStatus("מצמיד נתיבים (path) לפי ה־manifest...")
          let fixed = 0
          for (let i = 0; i < normalized.length; i++) {
            const it = normalized[i]
            const p = pathFromItemUsingMaps(it, maps)
            if (p && p !== it.path) { it.path = p; fixed++ }
if (i % 3000 === 0) {
              setStatus(`מצמיד נתיבים... (${i}/${normalized.length})`)
              await tick()
            }
          }

          setStatus(`מצמיד נתיבים... (${normalized.length}/${normalized.length})`)

          // בניית שדה חיפוש + קטגוריות (לפי נתיב תיקיות)
          const finalItems = []
          for (let i = 0; i < normalized.length; i++) {
            const it = normalized[i]
            const cat = computeCategoryFromPath(it.path)
            const q = buildSearchField(it)
            finalItems.push({
              title: it.title,
              author: it.author,
              path: it.path,
              id: it.id,
              _key: it._key,
              q,
              cat
            })
            if (i % 5000 === 0) await tick()
          }

          items = finalItems

          // שמירה במטמון (רק שדות דחוסים)
          try {
            const payload = {
              builtAt: Date.now(),
              items: items.map(compactItemForStorage),
              stats: {
                total: items.length,
                withPath: items.filter(x => x.path).length,
                fixed
              }
            }
            await idbSet(CATALOG_KEY, payload)
            setStatus(`נטען + נשמר במטמון | סה"כ: ${payload.stats.total} | עם קובץ: ${payload.stats.withPath} | הושלמו נתיבים: ${fixed}`)
          } catch (e) {
            console.warn("Cache save failed:", e)
            setStatus(`נטען (ללא שמירת מטמון) | סה"כ: ${items.length} | עם קובץ: ${items.filter(x => x.path).length}`)
          }

          afterCatalogLoaded()
        } catch (e) {
          console.error(e)
          setStatus("שגיאה")
          alert("שגיאה: " + (e && e.message ? e.message : e))
        } finally {
          btn.disabled = false
        }
      }

      async function backgroundRefresh() {
        try {
          // לא מפריעים למשתמש: רק משדרגים את המטמון ומעדכנים את ה־UI אם השתנה.
          const old = await idbGet(CATALOG_KEY)
          const oldAt = old && old.builtAt ? old.builtAt : 0
          await refreshCatalog(true)
          const now = await idbGet(CATALOG_KEY)
          if (now && now.builtAt && now.builtAt !== oldAt) {
            // כבר עודכן וה־UI עודכן ע"י refreshCatalog(true)
          }
        } catch (e) {
          console.warn("backgroundRefresh failed:", e)
        }
      }

      // =========================
      // Categories
      // =========================
      function computeCategoryFromPath(p) {
        const x = String(p || "").trim()
        if (!x) return []
        if (x.startsWith("http://") || x.startsWith("https://")) return []
        const parts = x.replaceAll("\\", "/").split("/").filter(Boolean)
        if (parts.length <= 1) return []
        // קטגוריה = כל התיקיות (ללא שם הקובץ)
        return parts.slice(0, parts.length - 1)
      }

      function buildCategoryTree(list) {
        const root = { name: "", segs: [], count: 0, children: new Map() }
        function getChild(parent, name, segs) {
          if (!parent.children.has(name)) {
            parent.children.set(name, { name, segs, count: 0, children: new Map() })
          }
          return parent.children.get(name)
        }

        for (const it of list) {
          if (!it.path) continue
          const segs = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)
          let node = root
          node.count++
          for (let i = 0; i < segs.length; i++) {
            const s = String(segs[i] || "").trim()
            if (!s) continue
            const nextSegs = segs.slice(0, i + 1)
            node = getChild(node, s, nextSegs)
            node.count++
          }
        }
        return root
      }

      function catKey(segs) {
        return (segs || []).join("/")
      }

      function toggleExpanded(segs) {
        const k = catKey(segs)
        if (expandedCategoryKeys.has(k)) expandedCategoryKeys.delete(k)
        else expandedCategoryKeys.add(k)
      }

      function selectCategory(segs) {
        selectedCategorySegs = Array.isArray(segs) ? segs : []
        // פותחים אוטומטית את הדרך עד הצומת שנבחר
        let acc = []
        for (const s of selectedCategorySegs) {
          acc = [...acc, s]
          expandedCategoryKeys.add(catKey(acc))
        }
        applySearch()
        scrollToResults()
        renderCategories()
      }

      function clearCategory() {
        selectedCategorySegs = []
        applySearch()
        renderCategories()
      }

      function renderCategories() {
        const box = document.getElementById("cats")
        if (!categoryRoot) {
          box.textContent = "—"
          return
        }
        box.innerHTML = ""
        const frag = document.createDocumentFragment()

        const children = Array.from(categoryRoot.children.values())
          .sort((a, b) => a.name.localeCompare(b.name, "he"))

        if (!children.length) {
          box.textContent = "אין קטגוריות (או שאין נתיבים)"
          return
        }

        for (const child of children) {
          frag.appendChild(renderCatNode(child, 0))
        }

        box.appendChild(frag)
      }

      function renderCatNode(node, depth) {
        const wrap = document.createElement("div")

        const row = document.createElement("div")
        row.className = "catRow"
        row.style.paddingRight = (depth * 14) + "px"

        const hasKids = node.children && node.children.size
        const toggle = document.createElement("button")
        toggle.className = "btnSmall catToggle"
        toggle.textContent = hasKids ? (expandedCategoryKeys.has(catKey(node.segs)) ? "▾" : "▸") : "•"
        toggle.disabled = !hasKids
        toggle.onclick = (e) => {
          e.stopPropagation()
          if (!hasKids) return
          toggleExpanded(node.segs)
          renderCategories()
        }

        const btn = document.createElement("button")
        btn.className = "catBtn" + (catKey(node.segs) === catKey(selectedCategorySegs) ? " selected" : "")
        btn.textContent = `${node.name} (${node.count})`
        btn.onclick = (e) => {
          e.stopPropagation()
          selectCategory(node.segs)
        }

        row.appendChild(toggle)
        row.appendChild(btn)
        wrap.appendChild(row)

        if (hasKids && expandedCategoryKeys.has(catKey(node.segs))) {
          const kids = Array.from(node.children.values())
            .sort((a, b) => a.name.localeCompare(b.name, "he"))
          for (const k of kids) {
            wrap.appendChild(renderCatNode(k, depth + 1))
          }
        }

        return wrap
      }

      // =========================
      // Search + render
      // =========================
      let searchTimer = null
      function onSearchInput() {
        clearTimeout(searchTimer)
        searchTimer = setTimeout(applySearch, 150)
      }

      function hasCategoryPrefix(it, segs) {
        if (!it || !it.path) return false
        const cat = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)
        if (cat.length < segs.length) return false
        for (let i = 0; i < segs.length; i++) {
          if (cat[i] !== segs[i]) return false
        }
        return true
      }

      
      function clearQuery() {
        const el = document.getElementById("q")
        if (el) el.value = ""
        applySearch()
      }

      function downloadMissing() {
        const missing = items
          .filter(it => !it.path)
          .map(it => {
            const strings = deepCollectStrings(it._raw, 6, 140)
            const hints = []
            for (const s of strings) {
              const x = String(s || "")
              if (!x) continue
              if (looksLikePath(x) || looksLikeHashish(x) || /\.(pdf|docx|epub|txt|zip|json)$/i.test(x) || /%22|["״׳'`´“”‘’]/.test(x)) {
                hints.push(x)
              }
            }
            return {
              title: it.title || "",
              author: it.author || "",
              id: it.id || "",
              key: it._key || "",
              hints: hints.slice(0, 30)
            }
          })

        const payload = {
          generatedAt: new Date().toISOString(),
          total: missing.length,
          items: missing
        }

        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json;charset=utf-8" })
        const a = document.createElement("a")
        a.href = URL.createObjectURL(blob)
        a.download = "missing_no_file.json"
        document.body.appendChild(a)
        a.click()
        a.remove()
        setTimeout(() => URL.revokeObjectURL(a.href), 5000)
      }

      // נרמול שמות לצורך התאמות "רופפות" (פיסוק/מרכאות/קידודים שונים)
      function normalizeKey(s) {
        let x = safeDecodeURIComponent(String(s ?? ""))
        try { x = x.normalize("NFKD") } catch (e) {}
        x = x
          .replace(/%22/gi, '"')
          .replace(/["״׳'`´“”‘’]/g, "")
          .replace(/[^\p{L}\p{N}]+/gu, " ")
          .replace(/\s+/g, " ")
          .trim()
          .toLowerCase()
        return x
      }

function applySearch() {
        const q = document.getElementById("q").value.trim().toLowerCase()
        const fileMode = document.getElementById("fileMode").value
        const searchAllCats = document.getElementById("searchAllCats").checked

        let base = items
        if (fileMode === "with") base = base.filter(it => it.path)
        else if (fileMode === "without") base = base.filter(it => !it.path)

        let scoped = base
        // כשיש קטגוריה נבחרת:
        // - אם אין חיפוש -> מסננים לפי קטגוריה
        // - אם יש חיפוש:
        //   - אם "חיפוש בכל הקטגוריות" דלוק -> לא מסננים לפי קטגוריה
        //   - אחרת -> מסננים לפי קטגוריה
        const hasCat = selectedCategorySegs && selectedCategorySegs.length
        if (hasCat && (!q || !searchAllCats)) {
          scoped = scoped.filter(it => hasCategoryPrefix(it, selectedCategorySegs))
        }

        currentList = q ? scoped.filter(it => (it.q || "").includes(q)) : scoped

        clearResults()
        renderNextPage()
        updateHeaderStats(q, fileMode, searchAllCats)
      }

      function updateHeaderStats(q, fileMode, searchAllCats) {
        const withPath = items.filter(it => it.path).length
        const withoutPath = items.length - withPath
        const modeLabel = (fileMode === "with") ? "רק עם קובץ" : (fileMode === "without") ? "רק בלי קובץ" : "הכל"
        const catLabel = selectedCategorySegs && selectedCategorySegs.length ? selectedCategorySegs.join(" / ") : "הכל"
        const scope = (q && searchAllCats) ? "כל הקטגוריות" : catLabel

        document.getElementById("scopeHint").textContent =
          `תחום: ${scope} | מצב: ${modeLabel} | מוצג: ${currentList.length} | סה"כ: ${items.length} | עם קובץ: ${withPath} | בלי קובץ: ${withoutPath}`

        document.getElementById("resultsTitle").textContent =
          q ? `תוצאות חיפוש (${currentList.length})` : `תוצאות (${currentList.length})`
      }

      function clearResults() {
        document.getElementById("results").innerHTML = ""
        renderCursor = 0
      }

      function renderNextPage() {
        const results = document.getElementById("results")
        const end = Math.min(renderCursor + PAGE_SIZE, currentList.length)

        for (let i = renderCursor; i < end; i++) {
          const it = currentList[i]

          const card = document.createElement("div")
          card.className = "card"

          const t = document.createElement("div")
          t.className = "title"
          t.textContent = it.title || "(ללא כותרת)"

          const m = document.createElement("div")
          m.className = "meta"
          m.textContent = it.author || ""

          const p = document.createElement("div")
          p.className = "path"
          p.textContent = it.path || ""

          const actions = document.createElement("div")
          actions.className = "actions"

          const b1 = document.createElement("button")
          b1.className = "btnSmall"
          b1.textContent = "פתח בטאב"
          b1.onclick = (e) => { e.stopPropagation(); openInNewTab(it.path) }

          const b2 = document.createElement("button")
          b2.className = "btnSmall"
          b2.textContent = "צפה כאן"
          b2.onclick = (e) => { e.stopPropagation(); viewInline(it.path) }

          const b3 = document.createElement("button")
          b3.className = "btnSmall"
          b3.textContent = "פתח קטגוריה"
          b3.onclick = (e) => {
            e.stopPropagation()
            const segs = Array.isArray(it.cat) ? it.cat : computeCategoryFromPath(it.path)
            if (segs.length) selectCategory(segs)
            else clearCategory()
          }

          actions.appendChild(b1)
          actions.appendChild(b2)
          actions.appendChild(b3)

          card.appendChild(t)
          card.appendChild(m)
          if (it.path) card.appendChild(p)
          card.appendChild(actions)

          card.onclick = () => openInNewTab(it.path)

          results.appendChild(card)
        }

        renderCursor = end
      }

      function afterCatalogLoaded() {
        // ברירת מחדל: לפתוח כמה קטגוריות ראשיות כדי שיהיה נוח
        categoryRoot = buildCategoryTree(items)
        expandedCategoryKeys = new Set()
        const top = Array.from(categoryRoot.children.values())
          .sort((a, b) => b.count - a.count)
          .slice(0, 8)
        for (const n of top) expandedCategoryKeys.add(catKey(n.segs))

        renderCategories()
        applySearch()

        // Infinite scroll
        window.onscroll = () => {
          if (renderCursor >= currentList.length) return
          const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 500)
          if (nearBottom) renderNextPage()
        }
      }

      // =========================
      // Boot
      // =========================
      document.addEventListener("DOMContentLoaded", () => {
        // טוען אוטומטית (מטמון אם קיים)
        refreshCatalog(false)
      })
    </script>
  </body>
</html>
