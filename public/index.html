<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ספרייה - קטלוג בסיסי</title>
    <style>
      body { font-family: system-ui, Arial; margin: 16px; }
      .row { margin-top: 10px; }
      .muted { color: #666; font-size: 13px; }
      input { width: 100%; padding: 10px; font-size: 16px; }
      button { padding: 10px 12px; font-size: 14px; margin: 6px 6px 6px 0; }
      .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
      .card { border: 1px solid #ddd; border-radius: 10px; padding: 10px; cursor: pointer; }
      .title { font-weight: 700; }
      .meta { margin-top: 6px; color: #444; font-size: 14px; }
      .path { margin-top: 6px; color: #888; font-size: 12px; direction: ltr; text-align: left; word-break: break-all; }
      a { word-break: break-all; }
      .toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .pill { padding: 4px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color: #444; }
      .viewerWrap { display: none; margin-top: 12px; }
      iframe { width: 100%; height: 70vh; border: 1px solid #ddd; border-radius: 10px; }
      label { user-select: none; }
    </style>
  </head>
  <body>
    <h2>קטלוג בסיסי — הממשק אצלך, הקבצים נשארים ב־GitHub</h2>
    <div class="muted">
      טוען metadata, משלים נתיבים מתוך files_manifest, ואז פותח דרך <code>/lib/...</code>.
    </div>

    <div class="row toolbar">
      <button id="btnLoad" onclick="loadCatalog()">טען קטלוג</button>
      <button onclick="scrollToResults()">לתוצאות</button>
      <button onclick="openPath()">פתח נתיב ידני</button>
      <button onclick="ping()">בדיקה: /api/ping</button>
      <label class="pill">
        <input id="showAll" type="checkbox" onchange="applySearch()" />
        הצג גם פריטים בלי קובץ
      </label>
      <span id="status" class="pill">לא נטען</span>
    </div>

    <div class="row">
      <input id="q" placeholder="חיפוש (כותרת/מחבר/נתיב)..." oninput="onSearchInput()" />
    </div>

    <h3 id="resultsTitle" style="margin-top:16px;">תוצאות</h3>
    <div id="results" class="grid"></div>

    <div class="row">
      <input id="path" placeholder="נתיב ידני בתוך הריפו (למשל: אוצריא/.../קובץ.pdf)" />
      <div class="muted">
        קישור נוכחי: <a id="link" href="#" target="_blank" rel="noreferrer">—</a>
      </div>
    </div>

    <div id="viewerWrap" class="viewerWrap">
      <h3 style="margin-top:0;">צפייה</h3>
      <iframe id="viewer" title="viewer"></iframe>
    </div>

    <script>
      let items = []
      let currentList = []
      let renderCursor = 0
      const PAGE_SIZE = 60

      function setStatus(text) {
        document.getElementById("status").textContent = text
      }

      function scrollToResults() {
        document.getElementById("resultsTitle").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function showViewer() {
        document.getElementById("viewerWrap").style.display = "block"
      }

      function encodePath(path) {
        return String(path)
          .split("/")
          .filter(Boolean)
          .map(encodeURIComponent)
          .join("/")
      }

      function libUrl(pathOrUrl) {
        const v = String(pathOrUrl || "").trim()
        if (!v) return ""
        if (v.startsWith("http://") || v.startsWith("https://")) return v
        return "/lib/" + encodePath(v)
      }

      function refreshLink(url) {
        const a = document.getElementById("link")
        a.textContent = url || "—"
        a.href = url || "#"
      }

      function openPath() {
        const p = document.getElementById("path").value.trim()
        const url = libUrl(p)
        if (!url) return
        refreshLink(url)
        showViewer()
        document.getElementById("viewer").src = url
        document.getElementById("viewerWrap").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function openItem(it) {
        if (!it.path) {
          alert(
            "אין נתיב לפתיחה עבור פריט זה.\n" +
            "נסה לסמן 'הצג גם פריטים בלי קובץ' כדי לראות מה מגיע.\n\n" +
            "דיבאג קצר:\n" +
            "id: " + (it.id || "") + "\n" +
            "_key: " + (it._key || "")
          )
          return
        }
        document.getElementById("path").value = it.path || ""
        const url = libUrl(it.path)
        refreshLink(url)
        showViewer()
        document.getElementById("viewer").src = url
        document.getElementById("viewerWrap").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;")
      }

      function tick() {
        return new Promise(r => setTimeout(r, 0))
      }

      // ---------- זיהויים

      function looksLikePath(s) {
        const x = String(s || "")
        if (!x) return false
        if (x.includes("://")) return true
        // נתיב צריך לפחות "/" + סיומת
        if ((x.includes("/") || x.includes("\\")) && /\.[a-z0-9]{2,6}$/i.test(x)) return true
        // סיומות שכיחות (גם בלי "/" - למקרים כמו "metadata.json")
        if (/\.(pdf|txt|docx|json|zip|md)$/i.test(x)) return true
        return false
      }

      function looksLikeHashish(s) {
        const x = String(s || "").trim()
        if (!x) return false
        // md5/sha1/sha256 או דומה
        if (/^[0-9a-f]{32}$/i.test(x)) return true
        if (/^[0-9a-f]{40}$/i.test(x)) return true
        if (/^[0-9a-f]{64}$/i.test(x)) return true
        // לפעמים יש prefix כמו "sha1:<hex>"
        if (/^(sha1|sha256|md5):[0-9a-f]{16,64}$/i.test(x)) return true
        return false
      }

      // ---------- טעינת JSON (מעדיף /api ואם אין אז /lib)

      async function fetchJsonAny(urls) {
        let lastErr = null
        for (const u of urls) {
          try {
            const r = await fetch(u, { cache: "no-store" })
            if (r.ok) return await r.json()
            lastErr = new Error(`${u} -> HTTP ${r.status}`)
          } catch (e) {
            lastErr = e
          }
        }
        throw lastErr || new Error("fetch failed")
      }

      // ---------- חילוץ metadata לרשימה

      function objectToArrayMap(obj) {
        const arr = []
        for (const [k, v] of Object.entries(obj || {})) {
          if (v && typeof v === "object") {
            arr.push({ ...v, _key: k })
          } else {
            arr.push({ title: String(v ?? "").trim(), _key: k })
          }
        }
        return arr
      }

      function extractBestCollection(json) {
        if (Array.isArray(json)) return json
        if (!json || typeof json !== "object") return []

        let bestArr = null
        let bestLen = -1
        for (const v of Object.values(json)) {
          if (Array.isArray(v) && v.length > bestLen) {
            bestArr = v
            bestLen = v.length
          }
        }
        if (bestArr) return bestArr

        const containerKeys = ["items", "books", "data", "metadata", "list"]
        for (const k of containerKeys) {
          const v = json[k]
          if (Array.isArray(v)) return v
          if (v && typeof v === "object") return objectToArrayMap(v)
        }

        const keys = Object.keys(json)
        if (keys.length) {
          const sampleN = Math.min(keys.length, 500)
          let score = 0
          for (let i = 0; i < sampleN; i++) {
            const kk = keys[i]
            if (looksLikePath(kk) || looksLikeHashish(kk)) score++
          }
          if (score / sampleN >= 0.15) return objectToArrayMap(json)
        }

        let bestObj = null
        let bestObjSize = 0
        for (const v of Object.values(json)) {
          if (v && typeof v === "object" && !Array.isArray(v)) {
            const size = Object.keys(v).length
            if (size > bestObjSize) {
              bestObjSize = size
              bestObj = v
            }
          }
        }
        if (bestObj && bestObjSize > 0) return objectToArrayMap(bestObj)

        return []
      }

      function normalizeMetaItem(x) {
        const o = (x && typeof x === "object") ? x : {}

        const titleVal =
          o.title ?? o.name ?? o.he_title ?? o.heb_title ?? o.book ?? o.display ?? ""

        const authorVal =
          o.author ?? o.authors ?? o.by ?? o.creator ?? o.writer ?? ""

        const pathVal =
          o.path ?? o.file ?? o.filename ?? o.relpath ?? o.uri ?? o.url ?? ""

        const idVal =
          o.id ?? o.hash ?? o.sha ?? o.sha1 ?? o.sha256 ?? o.md5 ?? o.filehash ?? o._key ?? ""

        const title = Array.isArray(titleVal) ? titleVal.join(" ") : titleVal
        const author = Array.isArray(authorVal) ? authorVal.join(", ") : authorVal
        const path = Array.isArray(pathVal) ? pathVal[0] : pathVal

        return {
          title: String(title || "").trim(),
          author: String(author || "").trim(),
          path: String(path || "").trim(),
          id: String(idVal || "").trim(),
          _key: String(o._key || "").trim(),
          _raw: o
        }
      }

      function collectCandidateIds(meta) {
        const out = new Set()

        const push = (v) => {
          if (typeof v !== "string") return
          const s = v.trim()
          if (!s) return
          if (s.length > 500) return
          out.add(s)
          // גם בלי prefix אם יש
          const m = s.match(/^(sha1|sha256|md5):(.+)$/i)
          if (m && m[2]) out.add(m[2])
        }

        push(meta.path)
        push(meta.id)
        push(meta._key)

        // חיפוש בעוד כמה שדות נפוצים מתוך _raw
        const r = meta._raw || {}
        const keys = ["file", "filename", "relpath", "uri", "url", "hash", "sha", "sha1", "sha256", "md5", "filehash"]
        for (const k of keys) {
          const v = r[k]
          if (typeof v === "string") push(v)
        }

        return Array.from(out)
      }

      // ---------- manifest -> anyId->path

      function extractManifestEntries(manifestJson) {
        if (!manifestJson || typeof manifestJson !== "object") return []
        const v = manifestJson.files || manifestJson.manifest || manifestJson.data || manifestJson
        if (!v || typeof v !== "object" || Array.isArray(v)) return []
        return Object.entries(v)
      }

      function collectStringsFromValue(val) {
        const out = []
        const push = (s) => {
          if (typeof s !== "string") return
          const x = s.trim()
          if (!x) return
          if (x.length > 500) return
          out.push(x)
          const m = x.match(/^(sha1|sha256|md5):(.+)$/i)
          if (m && m[2]) out.push(m[2])
        }

        if (typeof val === "string") {
          push(val)
          return out
        }

        if (val && typeof val === "object") {
          for (const v of Object.values(val)) {
            if (typeof v === "string") push(v)
          }
        }

        return out
      }

      async function buildAnyToPathMap(manifestJson, onProgress) {
        const anyToPath = new Map()
        const entries = extractManifestEntries(manifestJson)
        const total = entries.length

        for (let i = 0; i < total; i++) {
          const [k, vRaw] = entries[i]
          const kStr = String(k || "").trim()
          const vStrings = collectStringsFromValue(vRaw)

          // מנסים להסיק "path" מהצד שנראה כמו נתיב
          let path = ""
          if (looksLikePath(kStr)) {
            path = kStr
          } else {
            for (const s of vStrings) {
              if (looksLikePath(s)) {
                path = s
                break
              }
            }
          }

          if (path) {
            // ממפים גם את המפתח וגם כל מחרוזת שנמצאה לערך "path"
            if (kStr) anyToPath.set(kStr, path)
            for (const s of vStrings) anyToPath.set(s, path)
          } else {
            // גם אם לא זיהינו path, עדיין נשמור קשר בין key/value (לפעמים metadata מכיל key שמצביע ל-value אחר)
            if (kStr && vStrings.length) {
              for (const s of vStrings) {
                if (!anyToPath.has(kStr)) anyToPath.set(kStr, s)
                if (!anyToPath.has(s)) anyToPath.set(s, kStr)
              }
            }
          }

          if (i % 5000 === 0) {
            if (onProgress) onProgress(i, total)
            await tick()
          }
        }

        if (onProgress) onProgress(total, total)
        return anyToPath
      }

      function resolvePathFromMap(anyToPath, candidates) {
        for (const c of candidates) {
          if (anyToPath.has(c)) {
            const p = anyToPath.get(c)
            if (looksLikePath(p)) return p
            // אם זה לא path, אולי זה קפיצה אחת עד path
            if (anyToPath.has(p)) {
              const p2 = anyToPath.get(p)
              if (looksLikePath(p2)) return p2
            }
          }
        }
        return ""
      }

      // ---------- UI

      async function buildIndex(list, onProgress) {
        const out = []
        const total = list.length

        for (let i = 0; i < total; i++) {
          const it = list[i]
          const q = (it.title + " " + it.author + " " + it.path + " " + it.id + " " + it._key).toLowerCase()
          out.push({ ...it, q })

          if (i % 2000 === 0) {
            if (onProgress) onProgress(i, total)
            await tick()
          }
        }

        if (onProgress) onProgress(total, total)
        return out
      }

      function clearResults() {
        document.getElementById("results").innerHTML = ""
        renderCursor = 0
      }

      function renderNextPage() {
        const root = document.getElementById("results")
        const end = Math.min(renderCursor + PAGE_SIZE, currentList.length)

        for (let i = renderCursor; i < end; i++) {
          const it = currentList[i]
          const div = document.createElement("div")
          div.className = "card"
          div.innerHTML = `
            <div class="title">${escapeHtml(it.title || "(ללא כותרת)")}</div>
            <div class="meta">${escapeHtml(it.author || "")}</div>
            <div class="path">${escapeHtml(it.path || "(אין נתיב)")}</div>
          `
          div.onclick = () => openItem(it)
          root.appendChild(div)
        }

        renderCursor = end
      }

      function applySearch() {
        const q = document.getElementById("q").value.trim().toLowerCase()
        const showAll = document.getElementById("showAll").checked

        let base = items
        if (!showAll) base = base.filter(it => it.path)

        currentList = q ? base.filter(it => it.q.includes(q)) : base

        clearResults()
        renderNextPage()

        const withPath = items.filter(it => it.path).length
        const withoutPath = items.length - withPath
        setStatus(`סה"כ: ${items.length} | עם קובץ: ${withPath} | בלי קובץ: ${withoutPath} | מוצג: ${currentList.length}`)
      }

      let searchTimer = null
      function onSearchInput() {
        clearTimeout(searchTimer)
        searchTimer = setTimeout(applySearch, 150)
      }

      async function loadCatalog() {
        setStatus("טוען metadata...")
        document.getElementById("btnLoad").disabled = true

        try {
          const metaJson = await fetchJsonAny([
            "/api/metadata",
            "/lib/metadata.json"
          ])

          const rawMetaItems = extractBestCollection(metaJson)
          if (!rawMetaItems.length) {
            console.log("metadata json (raw):", metaJson)
            setStatus("נטען metadata אבל לא זוהתה רשימה")
            alert("נטען metadata.json אבל לא הצלחתי לחלץ ממנו רשימה. בדוק בקונסול (F12).")
            return
          }

          setStatus(`מעבד metadata... (0/${rawMetaItems.length})`)
          const normalized = []
          for (let i = 0; i < rawMetaItems.length; i++) {
            normalized.push(normalizeMetaItem(rawMetaItems[i]))
            if (i % 3000 === 0) {
              setStatus(`מעבד metadata... (${i}/${rawMetaItems.length})`)
              await tick()
            }
          }
          setStatus(`מעבד metadata... (${rawMetaItems.length}/${rawMetaItems.length})`)

          // בדיקה כמה פריטים כבר כוללים path
          let alreadyPath = 0
          for (let i = 0; i < normalized.length; i++) {
            if (looksLikePath(normalized[i].path)) alreadyPath++
          }

          let anyToPath = null

          // אם חסרים נתיבים – נטען manifest
          if (alreadyPath < normalized.length) {
            setStatus("טוען files_manifest...")
            const manifestJson = await fetchJsonAny([
              "/api/manifest",
              "/lib/files_manifest.json"
            ])

            setStatus("בונה מפת any→path... (0/?)")
            anyToPath = await buildAnyToPathMap(manifestJson, (done, total) => {
              setStatus(`בונה מפת any→path... (${done}/${total})`)
            })
          }

          // משלימים path לכל פריט
          setStatus(`משלים נתיבים... (0/${normalized.length})`)
          let filled = 0
          for (let i = 0; i < normalized.length; i++) {
            let p = normalized[i].path
            if (!looksLikePath(p) && anyToPath) {
              const candidates = collectCandidateIds(normalized[i])
              p = resolvePathFromMap(anyToPath, candidates)
            }
            normalized[i].path = looksLikePath(p) ? String(p).trim() : ""
            if (normalized[i].path) filled++

            if (i % 5000 === 0) {
              setStatus(`משלים נתיבים... (${i}/${normalized.length})`)
              await tick()
            }
          }
          setStatus(`משלים נתיבים... (${normalized.length}/${normalized.length})`)

          setStatus(`בונה אינדקס... (0/${normalized.length})`)
          items = await buildIndex(normalized, (done, total) => {
            setStatus(`בונה אינדקס... (${done}/${total})`)
          })

          // מציג תוצאות כברירת מחדל רק עם path
          document.getElementById("showAll").checked = false
          applySearch()
          scrollToResults()

          window.onscroll = () => {
            if (renderCursor >= currentList.length) return
            const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 400)
            if (nearBottom) renderNextPage()
          }
        } catch (e) {
          console.error(e)
          setStatus("שגיאה")
          alert("שגיאה: " + (e && e.message ? e.message : e))
        } finally {
          document.getElementById("btnLoad").disabled = false
        }
      }

      async function ping() {
        const r = await fetch("/api/ping")
        alert(await r.text())
      }
    </script>
  </body>
</html>
