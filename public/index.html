<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ספרייה - קטלוג בסיסי</title>
    <style>
      body { font-family: system-ui, Arial; margin: 16px; }
      .row { margin-top: 10px; }
      .muted { color: #666; font-size: 13px; }
      input { width: 100%; padding: 10px; font-size: 16px; }
      button { padding: 10px 12px; font-size: 14px; margin: 6px 6px 6px 0; }
      .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
      .card { border: 1px solid #ddd; border-radius: 10px; padding: 10px; cursor: pointer; }
      .title { font-weight: 700; }
      .meta { margin-top: 6px; color: #444; font-size: 14px; }
      .path { margin-top: 6px; color: #888; font-size: 12px; direction: ltr; text-align: left; word-break: break-all; }
      a { word-break: break-all; }
      .toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .pill { padding: 4px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color: #444; }
      .viewerWrap { display: none; margin-top: 12px; }
      iframe { width: 100%; height: 70vh; border: 1px solid #ddd; border-radius: 10px; }
    </style>
  </head>
  <body>
    <h2>קטלוג בסיסי — הקבצים נשארים ב־GitHub</h2>
    <div class="muted">
      נטען metadata ואז משלים נתיבים אמיתיים מתוך files_manifest (תומך גם path→hash וגם hash→path).
    </div>

    <div class="row toolbar">
      <button id="btnLoad" onclick="loadCatalog()">טען קטלוג</button>
      <button onclick="scrollToResults()">לתוצאות</button>
      <button onclick="openPath()">פתח נתיב ידני</button>
      <button onclick="ping()">בדיקה: /api/ping</button>
      <span id="status" class="pill">לא נטען</span>
    </div>

    <div class="row">
      <input id="q" placeholder="חיפוש (כותרת/מחבר/נתיב)..." oninput="onSearchInput()" />
    </div>

    <h3 id="resultsTitle" style="margin-top:16px;">תוצאות</h3>
    <div id="results" class="grid"></div>

    <div class="row">
      <input id="path" placeholder="נתיב ידני בתוך הריפו (למשל: אוצריא/.../קובץ.pdf)" />
      <div class="muted">
        קישור נוכחי: <a id="link" href="#" target="_blank" rel="noreferrer">—</a>
      </div>
    </div>

    <div id="viewerWrap" class="viewerWrap">
      <h3 style="margin-top:0;">צפייה</h3>
      <iframe id="viewer" title="viewer"></iframe>
    </div>

    <script>
      let items = []
      let currentList = []
      let renderCursor = 0
      const PAGE_SIZE = 60

      function setStatus(text) {
        document.getElementById("status").textContent = text
      }

      function scrollToResults() {
        document.getElementById("resultsTitle").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function showViewer() {
        document.getElementById("viewerWrap").style.display = "block"
      }

      function encodePath(path) {
        return String(path)
          .split("/")
          .filter(Boolean)
          .map(encodeURIComponent)
          .join("/")
      }

      function libUrl(pathOrUrl) {
        const v = String(pathOrUrl || "").trim()
        if (!v) return ""
        if (v.startsWith("http://") || v.startsWith("https://")) return v
        return "/lib/" + encodePath(v)
      }

      function refreshLink(url) {
        const a = document.getElementById("link")
        a.textContent = url || "—"
        a.href = url || "#"
      }

      function openPath() {
        const p = document.getElementById("path").value.trim()
        const url = libUrl(p)
        if (!url) return
        refreshLink(url)
        showViewer()
        document.getElementById("viewer").src = url
        document.getElementById("viewerWrap").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function openItem(it) {
        if (!it.path) {
          alert("אין נתיב לפתיחה עבור פריט זה (כנראה שה־manifest לא הותאם).")
          return
        }
        document.getElementById("path").value = it.path || ""
        const url = libUrl(it.path)
        refreshLink(url)
        showViewer()
        document.getElementById("viewer").src = url
        document.getElementById("viewerWrap").scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;")
      }

      // ---- Heuristics

      function looksLikePath(s) {
        const x = String(s || "")
        if (!x) return false
        if (x.includes("://")) return true
        if (x.includes("/") || x.includes("\\")) return true
        if (/\.(pdf|txt|docx)$/i.test(x)) return true
        return false
      }

      function looksLikeHash(s) {
        const x = String(s || "").trim()
        if (!x) return false
        // md5=32, sha1=40, sha256=64
        if (/^[0-9a-f]{32}$/i.test(x)) return true
        if (/^[0-9a-f]{40}$/i.test(x)) return true
        if (/^[0-9a-f]{64}$/i.test(x)) return true
        return false
      }

      // ---- Fetch helper (מעדיף /api ואם אין אז /lib)

      async function fetchJsonAny(urls) {
        let lastErr = null
        for (const u of urls) {
          try {
            const r = await fetch(u, { cache: "no-store" })
            if (r.ok) return await r.json()
            lastErr = new Error(`${u} -> HTTP ${r.status}`)
          } catch (e) {
            lastErr = e
          }
        }
        throw lastErr || new Error("fetch failed")
      }

      // ---- metadata extraction

      function objectToArrayMap(obj) {
        const arr = []
        for (const [k, v] of Object.entries(obj || {})) {
          if (v && typeof v === "object") {
            arr.push({ ...v, _key: k })
          } else {
            arr.push({ title: String(v ?? "").trim(), _key: k })
          }
        }
        return arr
      }

      function extractBestCollection(json) {
        if (Array.isArray(json)) return json
        if (!json || typeof json !== "object") return []

        // אם יש מערך ברמה העליונה – הכי גדול
        let bestArr = null
        let bestLen = -1
        for (const v of Object.values(json)) {
          if (Array.isArray(v) && v.length > bestLen) {
            bestArr = v
            bestLen = v.length
          }
        }
        if (bestArr) return bestArr

        // wrappers נפוצים
        const containerKeys = ["items", "books", "data", "metadata", "list"]
        for (const k of containerKeys) {
          const v = json[k]
          if (Array.isArray(v)) return v
          if (v && typeof v === "object") return objectToArrayMap(v)
        }

        // אם זה Object גדול עם מפתחות שנראים כמו נתיבים/האשים
        const keys = Object.keys(json)
        if (keys.length) {
          const sampleN = Math.min(keys.length, 500)
          let score = 0
          for (let i = 0; i < sampleN; i++) {
            const kk = keys[i]
            if (looksLikePath(kk) || looksLikeHash(kk)) score++
          }
          if (score / sampleN >= 0.15) return objectToArrayMap(json)
        }

        // רמה אחת פנימה: object הכי גדול
        let bestObj = null
        let bestObjSize = 0
        for (const v of Object.values(json)) {
          if (v && typeof v === "object" && !Array.isArray(v)) {
            const size = Object.keys(v).length
            if (size > bestObjSize) {
              bestObjSize = size
              bestObj = v
            }
          }
        }
        if (bestObj && bestObjSize > 0) return objectToArrayMap(bestObj)

        return []
      }

      function normalizeMetaItem(x) {
        const o = (x && typeof x === "object") ? x : {}

        const titleVal =
          o.title ?? o.name ?? o.he_title ?? o.heb_title ?? o.book ?? o.display ?? ""

        const authorVal =
          o.author ?? o.authors ?? o.by ?? o.creator ?? o.writer ?? ""

        const pathVal =
          o.path ?? o.file ?? o.filename ?? o.relpath ?? o.uri ?? o.url ?? ""

        // id/hash יכול להיות כאן או במפתח
        const idVal =
          o.id ?? o.hash ?? o.sha ?? o.sha1 ?? o.md5 ?? o.filehash ?? o._key ?? ""

        const title = Array.isArray(titleVal) ? titleVal.join(" ") : titleVal
        const author = Array.isArray(authorVal) ? authorVal.join(", ") : authorVal
        const path = Array.isArray(pathVal) ? pathVal[0] : pathVal

        return {
          title: String(title || "").trim(),
          author: String(author || "").trim(),
          path: String(path || "").trim(),
          id: String(idVal || "").trim(),
          _key: String(o._key || "").trim()
        }
      }

      function pickPathFromMeta(meta) {
        if (looksLikePath(meta.path)) return meta.path
        if (looksLikePath(meta._key)) return meta._key
        return ""
      }

      function pickHashFromMeta(meta) {
        // מנסה להוציא hash כדי להשלים path מהמניפסט
        if (looksLikeHash(meta.id)) return meta.id
        if (looksLikeHash(meta._key)) return meta._key
        if (looksLikeHash(meta.path)) return meta.path
        return ""
      }

      // ---- manifest parsing (תומך גם path->hash וגם hash->path)

      function extractManifestEntries(manifestJson) {
        if (!manifestJson || typeof manifestJson !== "object") return []
        const v = manifestJson.files || manifestJson.manifest || manifestJson.data || manifestJson
        if (!v || typeof v !== "object" || Array.isArray(v)) return []
        return Object.entries(v)
      }

      function getHashFromManifestValue(val) {
        if (typeof val === "string") return val
        if (val && typeof val === "object") {
          return val.hash || val.sha || val.sha1 || val.md5 || val.id || ""
        }
        return ""
      }

      async function buildManifestMaps(manifestJson, onProgress) {
        const hashToPath = new Map()
        const entries = extractManifestEntries(manifestJson)
        const total = entries.length

        for (let i = 0; i < total; i++) {
          const [k, vRaw] = entries[i]
          const v = getHashFromManifestValue(vRaw)

          const kIsPath = looksLikePath(k)
          const kIsHash = looksLikeHash(k)
          const vIsPath = looksLikePath(v)
          const vIsHash = looksLikeHash(v)

          // מקרה 1: path -> hash
          if (kIsPath && vIsHash) {
            if (!hashToPath.has(v)) hashToPath.set(v, k)
          }
          // מקרה 2: hash -> path
          else if (kIsHash && vIsPath) {
            if (!hashToPath.has(k)) hashToPath.set(k, v)
          }
          // מקרה 3: אם value הוא אובייקט ו-k הוא path ויש בו hash פנימי
          else if (kIsPath && !vIsHash && vRaw && typeof vRaw === "object") {
            const h2 = getHashFromManifestValue(vRaw)
            if (looksLikeHash(h2) && !hashToPath.has(h2)) hashToPath.set(h2, k)
          }

          if (i % 5000 === 0) {
            if (onProgress) onProgress(i, total)
            await new Promise(r => setTimeout(r, 0))
          }
        }

        if (onProgress) onProgress(total, total)
        return { hashToPath, entriesCount: total }
      }

      // ---- UI list build

      async function buildIndex(list, onProgress) {
        const out = []
        const total = list.length

        for (let i = 0; i < total; i++) {
          const it = list[i]
          const q = (it.title + " " + it.author + " " + it.path + " " + it.id + " " + it._key).toLowerCase()
          out.push({ ...it, q })

          if (i % 2000 === 0) {
            if (onProgress) onProgress(i, total)
            await new Promise(r => setTimeout(r, 0))
          }
        }

        if (onProgress) onProgress(total, total)
        return out
      }

      function clearResults() {
        document.getElementById("results").innerHTML = ""
        renderCursor = 0
      }

      function renderNextPage() {
        const root = document.getElementById("results")
        const end = Math.min(renderCursor + PAGE_SIZE, currentList.length)

        for (let i = renderCursor; i < end; i++) {
          const it = currentList[i]
          const div = document.createElement("div")
          div.className = "card"
          div.innerHTML = `
            <div class="title">${escapeHtml(it.title || "(ללא כותרת)")}</div>
            <div class="meta">${escapeHtml(it.author || "")}</div>
            <div class="path">${escapeHtml(it.path || "(אין נתיב)")}</div>
          `
          div.onclick = () => openItem(it)
          root.appendChild(div)
        }

        renderCursor = end
      }

      function applySearch() {
        const q = document.getElementById("q").value.trim().toLowerCase()
        currentList = q ? items.filter(it => it.q.includes(q)) : items
        clearResults()
        renderNextPage()
        setStatus(`נטען: ${items.length} | תוצאות: ${currentList.length}`)
      }

      let searchTimer = null
      function onSearchInput() {
        clearTimeout(searchTimer)
        searchTimer = setTimeout(applySearch, 150)
      }

      async function loadCatalog() {
        setStatus("טוען metadata...")
        document.getElementById("btnLoad").disabled = true

        try {
          // 1) metadata (מעדיף API, ואם אין אז דרך /lib)
          const metaJson = await fetchJsonAny([
            "/api/metadata",
            "/lib/metadata.json"
          ])

          const rawMetaItems = extractBestCollection(metaJson)
          if (!rawMetaItems.length) {
            console.log("metadata json (raw):", metaJson)
            setStatus("נטען metadata אבל לא זוהתה רשימה")
            alert("נטען metadata.json אבל לא הצלחתי לחלץ ממנו רשימה. בדוק בקונסול (F12).")
            return
          }

          setStatus(`מעבד metadata... (0/${rawMetaItems.length})`)
          let normalized = []
          for (let i = 0; i < rawMetaItems.length; i++) {
            normalized.push(normalizeMetaItem(rawMetaItems[i]))
            if (i % 3000 === 0) {
              setStatus(`מעבד metadata... (${i}/${rawMetaItems.length})`)
              await new Promise(r => setTimeout(r, 0))
            }
          }
          setStatus(`מעבד metadata... (${rawMetaItems.length}/${rawMetaItems.length})`)

          // 2) אם חסרים נתיבים, נשלים מה־manifest
          let missing = 0
          for (let i = 0; i < Math.min(normalized.length, 2000); i++) {
            if (!pickPathFromMeta(normalized[i])) missing++
          }

          let hashToPath = null

          if (missing > 0) {
            setStatus("טוען files_manifest...")
            const manifestJson = await fetchJsonAny([
              "/api/manifest",
              "/lib/files_manifest.json"
            ])

            setStatus("בונה מפת hash→path... (0/?)")
            const maps = await buildManifestMaps(manifestJson, (done, total) => {
              setStatus(`בונה מפת hash→path... (${done}/${total})`)
            })
            hashToPath = maps.hashToPath
          }

          // 3) השלמת path לכל פריט
          setStatus(`משלים נתיבים... (0/${normalized.length})`)
          for (let i = 0; i < normalized.length; i++) {
            let p = pickPathFromMeta(normalized[i])

            if (!p && hashToPath) {
              const h = pickHashFromMeta(normalized[i])
              if (h && hashToPath.has(h)) p = hashToPath.get(h)
            }

            normalized[i].path = String(p || "").trim()

            if (i % 5000 === 0) {
              setStatus(`משלים נתיבים... (${i}/${normalized.length})`)
              await new Promise(r => setTimeout(r, 0))
            }
          }
          setStatus(`משלים נתיבים... (${normalized.length}/${normalized.length})`)

          // 4) אינדוקס + סינון
          setStatus(`בונה אינדקס חיפוש... (0/${normalized.length})`)
          let indexed = await buildIndex(normalized, (done, total) => {
            setStatus(`בונה אינדקס חיפוש... (${done}/${total})`)
          })

          const before = indexed.length
          indexed = indexed.filter(it => it.path && looksLikePath(it.path))
          const after = indexed.length

          // אם עדיין הכל סונן, לא נשאיר אותך עם 0: נשאיר את הרשימה בלי סינון כדי שתראה מה מגיע מה־metadata
          if (after === 0 && before > 0) {
            items = await buildIndex(normalized, null)
            currentList = items
            clearResults()
            renderNextPage()
            setStatus(`נטען: 0 | סוננו: ${before} (אין נתיבי פתיחה – בדוק manifest)`)
            scrollToResults()
            return
          }

          items = indexed
          currentList = items
          clearResults()
          renderNextPage()
          setStatus(`נטען: ${after} | סוננו: ${before - after}`)
          scrollToResults()

          window.onscroll = () => {
            if (renderCursor >= currentList.length) return
            const nearBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 400)
            if (nearBottom) renderNextPage()
          }
        } catch (e) {
          console.error(e)
          setStatus("שגיאה")
          alert("שגיאה: " + (e && e.message ? e.message : e))
        } finally {
          document.getElementById("btnLoad").disabled = false
        }
      }

      async function ping() {
        const r = await fetch("/api/ping")
        alert(await r.text())
      }
    </script>
  </body>
</html>
