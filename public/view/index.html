<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Viewer</title>

    <script src="../vendor/purify.min.js"></script>
    <script src="../vendor/paged.polyfill.js"></script>
    <script src="../vendor/html-to-docx.umd.js"></script>
    <script src="../vendor/jszip.min.js"></script>

    <style>
      :root{
        --fs: 18px;
        --lh: 1.8;
        --readerMax: 980px;
        --pad: 18px;
      }

      *{ box-sizing: border-box; }
      body{
        font-family: system-ui, Arial;
        margin: 0;
        background: #fafafa;
      }

      body.book{
        --readerMax: 760px;
        --pad: 22px;
        --lh: 1.95;
      }

      .topbar{
        position: sticky;
        top: 0;
        z-index: 20;
        background: #fafafa;
        border-bottom: 1px solid #eee;
        padding: 10px 14px;
      }
      .row{
        display:flex;
        gap:10px;
        align-items:center;
        flex-wrap: wrap;
      }
      .btn{
        border: 1px solid #e5e5e5;
        background: #fff;
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
      }
      .btn:hover{ background:#f9f9f9; }
      .pill{
        font-size: 12px;
        color:#444;
        background:#fff;
        border:1px solid #eee;
        padding: 6px 10px;
        border-radius: 999px;
      }
      .spacer{ flex:1; }

      .catalogSearch{
        padding: 8px 12px;
        border:1px solid #e5e5e5;
        border-radius: 10px;
        min-width: 220px;
      }

      .wrap{
        max-width: 1180px;
        margin: 0 auto;
        padding: 18px 14px 36px;
      }

      .reader{
        max-width: var(--readerMax);
        margin: 0 auto;
      }

      .card{
        background: #fff;
        border: 1px solid #e5e5e5;
        border-radius: 12px;
        padding: var(--pad);
      }

      .title{
        font-weight: 800;
        font-size: 18px;
        margin-bottom: 10px;
      }

      .loading{
        font-size: 14px;
        color: #666;
      }

      .content{
        font-size: var(--fs);
        line-height: var(--lh);
      }

      .content h1{ font-size: 1.55em; margin: 0 0 10px 0; }
      .content h2{ font-size: 1.25em; margin: 18px 0 8px 0; }
      .content h3{ font-size: 1.1em; margin: 16px 0 6px 0; }

      .content p{ margin: 10px 0; }
      .content a{ color: inherit; }
      .content ul, .content ol{ margin: 10px 0 10px 0; padding-right: 22px; }

      .pre{
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: calc(var(--fs) - 3px);
        line-height: 1.65;
        direction: rtl;
      }

      iframe#pdf{
        width: 100%;
        height: calc(100vh - 190px);
        border: 0;
        border-radius: 12px;
        background: #f6f6f6;
      }

      .err{
        white-space: pre-wrap;
        color: #b00020;
        font-size: 14px;
      }

      /* Drawer (TOC) */
      .overlay{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.35);
        display: none;
        z-index: 50;
      }
      .overlay.open{ display:block; }

      .drawer{
        position: fixed;
        top: 0;
        bottom: 0;
        right: 0;
        width: min(420px, 92vw);
        background: #fff;
        border-left: 1px solid #eee;
        transform: translateX(100%);
        transition: transform .2s ease;
        z-index: 60;
        display: flex;
        flex-direction: column;
      }
      .drawer.open{ transform: translateX(0); }

      .drawerTop{
        display:flex;
        gap: 10px;
        align-items:center;
        padding: 12px 12px;
        border-bottom: 1px solid #eee;
        background: #fafafa;
      }
      .drawerTitle{ font-weight: 800; }
      .tocList{
        padding: 8px 8px 18px;
        overflow:auto;
      }
      .tocItem{
        padding: 8px 10px;
        border-radius: 10px;
        cursor: pointer;
        border: 1px solid transparent;
        margin: 6px 0;
      }
      .tocItem:hover{
        border-color: #eee;
        background: #fafafa;
      }
      .lvl1{ padding-right: 14px; font-weight: 700; }
      .lvl2{ padding-right: 24px; }
      .lvl3{ padding-right: 34px; }
      .lvl4{ padding-right: 44px; }

      /* --- Commentaries Split View --- */
      .splitWrap{
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        align-items: stretch;
      }
      .splitWrap.showComms{
        grid-template-columns: 420px 1fr;
      }

      .txtPane{
        border: 1px solid #eee;
        border-radius: 12px;
        background: #fff;
        overflow: auto;
        max-height: calc(100vh - 210px);
        padding: 10px 12px;
      }
      .txtLines{
        font-size: var(--fs);
        line-height: var(--lh);
        direction: rtl;
      }
      .ln{
        padding: 2px 0;
        border-radius: 8px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .ln.hit{
        background: #fff7cc;
      }

      .commPanel{
        border: 1px solid #eee;
        border-radius: 12px;
        background: #fff;
        overflow: hidden;
        max-height: calc(100vh - 210px);
        display: flex;
        flex-direction: column;
      }
      .commTop{
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 10px 10px;
        border-bottom: 1px solid #eee;
        background: #fafafa;
      }
      .commSel, .commMode{
        flex: 1;
        padding: 7px 8px;
        border-radius: 10px;
        border: 1px solid #e5e5e5;
        background: #fff;
        font-size: 14px;
      }
      .btn.mini{
        padding: 7px 10px;
        font-size: 13px;
      }
      .commMeta{
        padding: 8px 10px;
        font-size: 12px;
        color: #666;
        border-bottom: 1px solid #f0f0f0;
      }
      .commBody{
        padding: 10px 12px;
        overflow: auto;
        font-size: calc(var(--fs) - 1px);
        line-height: var(--lh);
      }
      .commLine{
        padding: 2px 0;
        border-radius: 8px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .commLine.hit{
        background: #eaffea;
      }

      @media (max-width: 860px){
        .splitWrap.showComms{
          grid-template-columns: 1fr;
        }
        .commPanel{
          max-height: 45vh;
        }
        .txtPane{
          max-height: 55vh;
        }
      }
    </style>
  </head>

  <body>
    <div class="topbar">
      <div class="row">
        <button class="btn" id="btnHome">בית</button>
        <button class="btn" id="btnCatalog">קטלוג</button>
        <input class="catalogSearch" id="catalogSearch" placeholder="חיפוש בקטלוג..." />
        <button class="btn" id="btnCatalogSearch">חפש</button>
        <button class="btn" id="btnRaw">פתח מקור (RAW)</button>
        <button class="btn" id="btnToc" style="display:none;">תוכן עניינים</button>

        <button class="btn" id="btnComms" style="display:none;">מפרשים</button>

        <button class="btn" id="btnExportPdf" style="display:none;">ייצוא PDF</button>
        <button class="btn" id="btnExportDocx" style="display:none;">ייצוא DOCX</button>
        <button class="btn" id="btnExportEpub" style="display:none;">ייצוא EPUB</button>

        <span class="pill" id="fontLabel">גופן: —</span>
        <button class="btn" id="btnMinus" title="הקטן גופן">−</button>
        <button class="btn" id="btnPlus" title="הגדל גופן">+</button>
        <button class="btn" id="btnBook" title="מצב עמוד ספר">עמוד ספר: כבוי</button>
      </div>
    </div>

    <div class="wrap">
      <div class="reader">
        <div class="card" id="card">
          <div class="loading" id="loading">טוען…</div>

          <div class="content" id="content" style="display:none;"></div>
          <pre class="pre" id="pre" style="display:none;"></pre>
          <div class="splitWrap" id="splitWrap" style="display:none;">
            <div class="commPanel" id="commPanel" style="display:none;">
              <div class="commTop">
                <select class="commSel" id="commSel"></select>
                <select class="commMode" id="commMode">
                  <option value="linked">מפרש מקושר</option>
                  <option value="page">צורת הדף</option>
                </select>
                <button class="btn mini" id="btnCommRaw" title="פתח מקור (RAW)">RAW</button>
                <button class="btn mini" id="btnCommClose" title="סגור">✕</button>
              </div>
              <div class="commMeta" id="commMeta"></div>
              <div class="commBody" id="commBody"></div>
            </div>

            <div class="txtPane" id="txtPane">
              <div class="txtLines" id="txtLines"></div>
            </div>
          </div>

          <div class="err" id="err" style="display:none;"></div>
          <iframe id="pdf" style="display:none;"></iframe>
        </div>
      </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <aside class="drawer" id="drawer">
      <div class="drawerTop">
        <div class="drawerTitle">תוכן עניינים</div>
        <span class="spacer"></span>
        <button class="btn" id="btnCloseToc">סגור</button>
      </div>
      <div class="tocList" id="tocList"></div>
    </aside>

    <script>

      let currentPath = ""
      let currentSafeHtml = ""
      let currentPlainText = ""
      let currentTocItems = [] // [{id,label,level}]
      let commUI = null
      let commState = {
        active: false,
        basePath: "",
        baseFile: "",
        mainLines: [],
        mainEls: [],
        mainTops: [],
        commentaries: [],
        selected: null,
        commText: "",
        commLines: [],
        commEls: [],
        commTops: [],
        links: [],
        mode: "linked",
        lastMainLine: -1,
        raf: 0,
        needMeasure: true,
        needMeasureComm: true,
      }

      function encodePath(path){
        return String(path).split("/").filter(Boolean).map(encodeURIComponent).join("/")
      }

      function getParam(name){
        const u = new URL(location.href)
        return u.searchParams.get(name) || ""
      }

      function isPdf(path){
        return /\.pdf$/i.test(path)
      }

      function looksLikeHtml(text){
        const t = String(text || "").trim()
        return t.startsWith("<!doctype") || t.startsWith("<html") || t.startsWith("<div") || t.includes("<h1") || t.includes("<h2") || t.includes("<p")
      }

      function sanitizeHtml(html){
        if (window.DOMPurify){
          return window.DOMPurify.sanitize(html, {
            USE_PROFILES: { html: true },
            ADD_ATTR: ["id", "name"],
          })
        }
        return html
      }

      function clamp(n, a, b){
        return Math.max(a, Math.min(b, n))
      }

      function savePrefs(p){
        localStorage.setItem("view_fs", String(p.fs))
        localStorage.setItem("view_book", p.book ? "1" : "0")
      }

      function loadPrefs(){
        const fs = Number(localStorage.getItem("view_fs") || "18")
        const book = localStorage.getItem("view_book") === "1"
        return { fs: clamp(Number.isFinite(fs) ? fs : 18, 12, 34), book }
      }

      function applyPrefs(p){
        document.documentElement.style.setProperty("--fs", p.fs + "px")
        document.getElementById("fontLabel").textContent = "גופן: " + p.fs
        document.body.classList.toggle("book", !!p.book)
        document.getElementById("btnBook").textContent = "עמוד ספר: " + (p.book ? "פעיל" : "כבוי")
        invalidateMeasures()
      }

      function slug(text){
        const t = String(text || "").trim()
        return t.replace(/\s+/g,"-").replace(/[^\u0590-\u05FFa-zA-Z0-9\-]/g, "")
      }

      function buildTocFromHtml(){
        const host = document.getElementById("content")
        const hs = host.querySelectorAll("h1,h2,h3,h4")
        const items = []
        let i = 0
        for (const h of hs){
          const lvl = Number(h.tagName.substring(1))
          const label = (h.textContent || "").trim()
          if (!label) continue
          if (!h.id){
            h.id = "h-" + lvl + "-" + i + "-" + slug(label).slice(0, 24)
          }
          items.push({ id: h.id, label, level: lvl })
          i++
        }
        return items
      }

      function renderToc(items){
        const list = document.getElementById("tocList")
        list.innerHTML = ""
        for (const it of items){
          const d = document.createElement("div")
          d.className = "tocItem lvl" + it.level
          d.textContent = it.label
          d.onclick = () => {
            closeToc()
            scrollToId(it.id)
          }
          list.appendChild(d)
        }
      }

      function scrollToId(id){
        const el = document.getElementById(id)
        if (!el) return
        el.scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function openToc(){
        document.getElementById("overlay").classList.add("open")
        document.getElementById("drawer").classList.add("open")
      }

      function closeToc(){
        document.getElementById("overlay").classList.remove("open")
        document.getElementById("drawer").classList.remove("open")
      }

      function showExportButtonsForHtmlOrText(){
        document.getElementById("btnExportPdf").style.display = "inline-block"
        document.getElementById("btnExportDocx").style.display = "inline-block"
        document.getElementById("btnExportEpub").style.display = "inline-block"
      }

      function hideExportButtons(){
        document.getElementById("btnExportPdf").style.display = "none"
        document.getElementById("btnExportDocx").style.display = "none"
        document.getElementById("btnExportEpub").style.display = "none"
      }

      function downloadBlob(blob, filename){
        const a = document.createElement("a")
        const url = URL.createObjectURL(blob)
        a.href = url
        a.download = filename
        document.body.appendChild(a)
        a.click()
        a.remove()
        setTimeout(() => URL.revokeObjectURL(url), 5000)
      }

      async function exportPdfFromHtml(html){
        if (!window.PagedPolyfill){
          alert("Paged.js לא נטען")
          return
        }
        const iframe = document.createElement("iframe")
        iframe.style.position = "fixed"
        iframe.style.right = "-9999px"
        iframe.style.width = "800px"
        iframe.style.height = "600px"
        document.body.appendChild(iframe)

        const doc = iframe.contentDocument
        doc.open()
        doc.write("<!doctype html><html dir='rtl' lang='he'><head><meta charset='utf-8'>")
        doc.write("<style>body{font-family:system-ui,Arial;direction:rtl;font-size:16px;line-height:1.8} h1,h2,h3{page-break-after:avoid} pre{white-space:pre-wrap;word-break:break-word}</style>")
        doc.write("</head><body>")
        doc.write(html)
        doc.write("</body></html>")
        doc.close()

        await window.PagedPolyfill.preview(doc.body, [], doc)

        const r = await fetch(iframe.src || "")
        document.body.removeChild(iframe)
        return r
      }

      async function exportDocxFromHtml(html){
        if (!window.htmlToDocx){
          alert("html-to-docx לא נטען")
          return
        }
        const blob = await window.htmlToDocx(html, null, {
          table: { row: { cantSplit: true } },
          footer: false,
          pageNumber: false,
        })
        return blob
      }

      async function exportEpubFromHtml(html){
        if (!window.JSZip){
          alert("JSZip לא נטען")
          return
        }
        const zip = new window.JSZip()
        const contentOpf = `<?xml version="1.0" encoding="utf-8"?>
<package version="3.0" unique-identifier="BookId" xmlns="http://www.idpf.org/2007/opf">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:identifier id="BookId">urn:uuid:${crypto.randomUUID()}</dc:identifier>
    <dc:title>Book</dc:title>
    <dc:language>he</dc:language>
  </metadata>
  <manifest>
    <item id="toc" properties="nav" href="nav.xhtml" media-type="application/xhtml+xml"/>
    <item id="content" href="content.xhtml" media-type="application/xhtml+xml"/>
  </manifest>
  <spine>
    <itemref idref="content"/>
  </spine>
</package>`
        const navXhtml = `<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" dir="rtl" lang="he">
  <head><title>TOC</title></head>
  <body>
    <nav epub:type="toc" id="toc"><ol><li><a href="content.xhtml">תוכן</a></li></ol></nav>
  </body>
</html>`
        const contentXhtml = `<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" dir="rtl" lang="he">
  <head><title>Content</title></head>
  <body>${html}</body>
</html>`

        zip.file("mimetype", "application/epub+zip", { compression: "STORE" })
        zip.folder("META-INF").file("container.xml",
          `<?xml version="1.0"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`
        )
        const oebps = zip.folder("OEBPS")
        oebps.file("content.opf", contentOpf)
        oebps.file("nav.xhtml", navXhtml)
        oebps.file("content.xhtml", contentXhtml)

        const blob = await zip.generateAsync({ type: "blob" })
        return blob
      }

      function escHtml(s){
        return String(s || "")
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
      }

      function splitLines(text){
        const t = String(text || "").replaceAll("\r\n","\n").replaceAll("\r","\n")
        return t.split("\n")
      }

      function upperBound(arr, x){
        let lo = 0
        let hi = arr.length
        while (lo < hi){
          const mid = (lo + hi) >> 1
          if (arr[mid] <= x) lo = mid + 1
          else hi = mid
        }
        return lo
      }

      function invalidateMeasures(){
        commState.needMeasure = true
        commState.needMeasureComm = true
      }

      function measureMain(){
        if (!commUI) return
        const els = Array.from(commUI.txtLines.querySelectorAll(".ln"))
        commState.mainEls = els
        commState.mainTops = els.map(el => el.offsetTop)
        commState.needMeasure = false
      }

      function measureComm(){
        if (!commUI) return
        const els = Array.from(commUI.commBody.querySelectorAll(".commLine"))
        commState.commEls = els
        commState.commTops = els.map(el => el.offsetTop)
        commState.needMeasureComm = false
      }

      function pickMainLine(){
        if (!commUI) return 0
        if (commState.needMeasure) measureMain()
        const st = commUI.txtPane.scrollTop
        const idx = Math.max(0, upperBound(commState.mainTops, st + 12) - 1)
        return idx
      }

      function findLinkIndexByBaseLine(lineIdx){
        const links = commState.links || []
        if (!links.length) return -1
        let lo = 0
        let hi = links.length
        while (lo < hi){
          const mid = (lo + hi) >> 1
          if (links[mid].baseLine <= lineIdx) lo = mid + 1
          else hi = mid
        }
        return Math.max(0, lo - 1)
      }

      function clearHits(){
        if (!commUI) return
        for (const el of commState.mainEls){
          el.classList.remove("hit")
        }
        for (const el of commState.commEls){
          el.classList.remove("hit")
        }
      }

      function markMainHit(lineIdx){
        if (!commUI) return
        const el = commState.mainEls[lineIdx]
        if (el) el.classList.add("hit")
      }

      function markCommHit(start, endExcl){
        if (!commUI) return
        const n = commState.commEls.length
        const s = Math.max(0, Math.min(n - 1, start))
        const e = Math.max(0, Math.min(n, endExcl))
        for (let i = s; i < e; i++){
          commState.commEls[i].classList.add("hit")
        }
      }

      function scrollCommTo(lineIdx){
        if (!commUI) return
        if (commState.needMeasureComm) measureComm()
        const el = commState.commEls[lineIdx]
        if (!el) return
        const top = el.offsetTop - 12
        commUI.commBody.scrollTo({ top, behavior: "smooth" })
      }

      function renderLinkedSnippet(start, endExcl){
        const lines = commState.commLines || []
        const s = Math.max(0, Math.min(lines.length, start))
        const e = Math.max(s, Math.min(lines.length, endExcl))
        const snippet = lines.slice(s, e).join("\n").trim()
        commUI.commBody.textContent = snippet || "—"
      }

      function renderCommentaryFull(){
        const lines = commState.commLines || []
        let html = ""
        for (let i = 0; i < lines.length; i++){
          html += `<div class="commLine" data-i="${i}">${escHtml(lines[i])}</div>`
        }
        commUI.commBody.innerHTML = html
        commState.needMeasureComm = true
        requestAnimationFrame(() => {
          if (!commUI) return
          measureComm()
        })
      }

      function syncCommentaryToLine(lineIdx, force){
        if (!commUI) return
        if (!commState.active) return
        if (!commState.selected) return
        if (!commState.links || !commState.links.length) return

        if (!force && lineIdx === commState.lastMainLine) return
        commState.lastMainLine = lineIdx

        const li = findLinkIndexByBaseLine(lineIdx)
        const cur = commState.links[li]
        const next = commState.links[li + 1]

        if (!cur) return

        const commStart = cur.commLine
        const commEnd = next ? next.commLine : Math.min(commStart + 30, (commState.commLines || []).length)

        clearHits()
        markMainHit(cur.baseLine)

        if (commState.mode === "linked"){
          renderLinkedSnippet(commStart, commEnd)
        } else {
          if (!commUI.commBody.querySelector(".commLine")){
            renderCommentaryFull()
          }
          if (commState.needMeasureComm) measureComm()
          scrollCommTo(commStart)
          markCommHit(commStart, commEnd)
        }
      }

      function syncCommentaryToMain(force){
        if (!commUI) return
        if (!commState.active) return

        if (commState.raf) return
        commState.raf = requestAnimationFrame(() => {
          commState.raf = 0
          const lineIdx = pickMainLine()
          syncCommentaryToLine(lineIdx, !!force)
        })
      }

      async function fetchLibText(path){
        const url = "/lib/" + encodePath(path)
        const r = await fetch(url, { cache: "no-cache" })
        if (!r.ok){
          throw new Error("Fetch failed: " + r.status + " " + url)
        }
        return await r.text()
      }

      function setCommsOpen(open){
        if (!commUI) return
        commUI.commPanel.style.display = open ? "flex" : "none"
        commUI.splitWrap.classList.toggle("showComms", !!open)
        if (open) syncCommentaryToMain(true)
      }

      async function loadCommentary(item){
        if (!commUI) return
        commState.selected = item
        commUI.commMeta.textContent = "טוען…"
        commUI.commBody.textContent = ""

        const commText = await fetchLibText(item.book_path)
        commState.commText = commText
        commState.commLines = splitLines(commText)

        const linksText = await fetchLibText(item.links_path)
        let links
        try {
          links = JSON.parse(linksText)
        } catch (_) {
          links = []
        }

        const baseFile = commState.baseFile
        const norm = []
        for (const e of Array.isArray(links) ? links : []){
          const commLine = Number(e.line_index_1)
          const baseLine = Number(e.line_index_2)
          if (!Number.isFinite(commLine) || !Number.isFinite(baseLine)) continue

          const path2 = String(e.path_2 || e.path2 || "")
          const type = String(e["Conection Type"] || e["Connection Type"] || e.type || "")
          norm.push({
            commLine,
            baseLine,
            path2,
            ref2: String(e.heRef_2 || e.ref_2 || ""),
            type,
          })
        }

        const matching = baseFile ? norm.filter(x => x.path2 === baseFile) : norm
        const finalLinks = matching.length ? matching : norm
        finalLinks.sort((a, b) => a.baseLine - b.baseLine)
        commState.links = finalLinks

        commState.mode = String(commUI.commMode.value || "linked")
        commState.lastMainLine = -1
        commState.needMeasureComm = true

        commUI.btnCommRaw.onclick = () => {
          const u = "/lib/" + encodePath(item.book_path)
          window.open(u, "_blank", "noopener,noreferrer")
        }

        const count = finalLinks.length
        commUI.commMeta.textContent =
          item.title + " • " + count + " קישורים" + (matching.length ? "" : " (לא מסונן)")

        if (commState.mode === "linked"){
          commUI.commBody.textContent = "—"
        } else {
          renderCommentaryFull()
        }

        syncCommentaryToMain(true)
      }

      async function loadCommentariesList(basePath){
        if (!commUI) return

        commState.active = false
        commState.basePath = basePath
        commState.baseFile = String(basePath || "").split("/").pop() || ""

        commUI.btnComms.style.display = "none"
        commUI.commSel.innerHTML = ""
        commUI.commMeta.textContent = ""
        commUI.commBody.textContent = ""
        commUI.commPanel.style.display = "none"
        commUI.splitWrap.classList.remove("showComms")

        let data
        try {
          const r = await fetch("/api/commentaries?path=" + encodeURIComponent(basePath), { cache: "no-cache" })
          if (!r.ok) return
          data = await r.json()
        } catch (_) {
          return
        }

        const list = Array.isArray(data && data.commentaries) ? data.commentaries : []
        commState.commentaries = list
        if (!list.length) return

        commUI.btnComms.style.display = "inline-block"

        let opts = ""
        for (let i = 0; i < list.length; i++){
          const t = list[i].title || ("מפרש " + (i + 1))
          opts += `<option value="${i}">${escHtml(t)}</option>`
        }
        commUI.commSel.innerHTML = opts

        commUI.commMode.onchange = () => {
          commState.mode = String(commUI.commMode.value || "linked")
          commState.lastMainLine = -1
          commState.needMeasureComm = true
          if (commState.mode === "page"){
            renderCommentaryFull()
          } else {
            commUI.commBody.textContent = "—"
          }
          syncCommentaryToMain(true)
        }

        commUI.commSel.onchange = async () => {
          const i = Number(commUI.commSel.value)
          const item = list[i]
          if (!item) return
          await loadCommentary(item)
        }

        commState.active = true
        setCommsOpen(true)
        await loadCommentary(list[0])
      }

      function buildMainLines(text){
        if (!commUI) return
        const lines = splitLines(text)
        commState.mainLines = lines

        let html = ""
        for (let i = 0; i < lines.length; i++){
          html += `<div class="ln" data-i="${i}">${escHtml(lines[i])}</div>`
        }

        commUI.txtLines.innerHTML = html
        commState.needMeasure = true
        requestAnimationFrame(() => {
          if (!commUI) return
          measureMain()
        })
      }

      async function main(){
        const prefs = loadPrefs()
        applyPrefs(prefs)

        document.getElementById("btnPlus").onclick = () => {
          const p = loadPrefs()
          p.fs = clamp(p.fs + 1, 12, 34)
          savePrefs(p)
          applyPrefs(p)
        }
        document.getElementById("btnMinus").onclick = () => {
          const p = loadPrefs()
          p.fs = clamp(p.fs - 1, 12, 34)
          savePrefs(p)
          applyPrefs(p)
        }
        document.getElementById("btnBook").onclick = () => {
          const p = loadPrefs()
          p.book = !p.book
          savePrefs(p)
          applyPrefs(p)
        }

        document.getElementById("btnCloseToc").onclick = closeToc
        document.getElementById("overlay").onclick = closeToc

        const path = getParam("path")
        currentPath = path

        const loading = document.getElementById("loading")
        const content = document.getElementById("content")
        const pre = document.getElementById("pre")
        const err = document.getElementById("err")
        const pdf = document.getElementById("pdf")
        const btnRaw = document.getElementById("btnRaw")
        const btnComms = document.getElementById("btnComms")
        const splitWrap = document.getElementById("splitWrap")
        const txtPane = document.getElementById("txtPane")
        const txtLines = document.getElementById("txtLines")

        const commPanel = document.getElementById("commPanel")
        const commSel = document.getElementById("commSel")
        const commMode = document.getElementById("commMode")
        const commMeta = document.getElementById("commMeta")
        const commBody = document.getElementById("commBody")
        const btnCommClose = document.getElementById("btnCommClose")
        const btnCommRaw = document.getElementById("btnCommRaw")

        commUI = {
          btnComms,
          splitWrap,
          txtPane,
          txtLines,
          commPanel,
          commSel,
          commMode,
          commMeta,
          commBody,
          btnCommClose,
          btnCommRaw,
        }

        // Reset panes
        btnComms.style.display = "none"
        splitWrap.style.display = "none"
        commPanel.style.display = "none"
        splitWrap.classList.remove("showComms")

        btnComms.onclick = () => {
          const open = commPanel.style.display === "none"
          setCommsOpen(open)
        }
        btnCommClose.onclick = () => {
          setCommsOpen(false)
        }

        txtPane.onscroll = () => {
          syncCommentaryToMain(false)
        }

        if (!path){
          loading.style.display = "none"
          err.style.display = "block"
          err.textContent = "Missing ?path="
          return
        }

        btnRaw.onclick = () => {
          const u = "/lib/" + encodePath(path)
          window.open(u, "_blank", "noopener,noreferrer")
        }

        document.getElementById("btnHome").onclick = () => {
          location.href = "/"
        }
        document.getElementById("btnCatalog").onclick = () => {
          location.href = "/catalog/"
        }

        document.getElementById("btnCatalogSearch").onclick = () => {
          const q = (document.getElementById("catalogSearch").value || "").trim()
          location.href = "/catalog/?q=" + encodeURIComponent(q)
        }

        document.getElementById("btnToc").onclick = () => {
          openToc()
        }

        document.getElementById("btnExportPdf").onclick = async () => {
          if (currentSafeHtml){
            const r = await exportPdfFromHtml(currentSafeHtml)
            if (r && r.ok){
              const blob = await r.blob()
              downloadBlob(blob, "book.pdf")
              return
            }
          }
          alert("PDF export failed")
        }

        document.getElementById("btnExportDocx").onclick = async () => {
          let html = currentSafeHtml
          if (!html && currentPlainText){
            html = "<pre>" + escHtml(currentPlainText) + "</pre>"
          }
          if (!html){
            alert("אין תוכן לייצוא")
            return
          }
          const blob = await exportDocxFromHtml(html)
          if (blob) downloadBlob(blob, "book.docx")
        }

        document.getElementById("btnExportEpub").onclick = async () => {
          let html = currentSafeHtml
          if (!html && currentPlainText){
            html = "<pre>" + escHtml(currentPlainText) + "</pre>"
          }
          if (!html){
            alert("אין תוכן לייצוא")
            return
          }
          const blob = await exportEpubFromHtml(html)
          if (blob) downloadBlob(blob, "book.epub")
        }

        hideExportButtons()

        if (isPdf(path)){
          loading.style.display = "none"
          pdf.style.display = "block"
          pdf.src = "/lib/" + encodePath(path)
          document.getElementById("btnToc").style.display = "none"
          hideExportButtons()
          return
        }

        const url = "/lib/" + encodePath(path)
        const r = await fetch(url, { cache: "no-cache" })
        if (!r.ok){
          loading.style.display = "none"
          err.style.display = "block"
          err.textContent = "Fetch failed: " + r.status + "\n" + url
          return
        }

        const text = await r.text()
        loading.style.display = "none"

        if (looksLikeHtml(text)){
          const safe = sanitizeHtml(text)
          if (safe && safe.trim().length > 10){
            content.style.display = "block"
            content.innerHTML = safe
            currentSafeHtml = safe
            currentPlainText = ""
            splitWrap.style.display = "none"
            pre.style.display = "none"

            const items = buildTocFromHtml()
            currentTocItems = items
            if (items.length){
              document.getElementById("btnToc").style.display = "inline-block"
              renderToc(items)
            } else {
              document.getElementById("btnToc").style.display = "none"
            }

            showExportButtonsForHtmlOrText()
            return
          }
        }

        // Plain text
        pre.textContent = text
        currentPlainText = text
        currentSafeHtml = ""
        currentTocItems = []
        document.getElementById("btnToc").style.display = "none"
        showExportButtonsForHtmlOrText()

        const enableComms =
          /\.txt$/i.test(path || "") &&
          !String(path).includes("/מפרשים/") &&
          !String(path).includes("/links/")

        if (enableComms){
          content.style.display = "none"
          pre.style.display = "none"
          splitWrap.style.display = "grid"

          buildMainLines(text)
          await loadCommentariesList(path)
        } else {
          splitWrap.style.display = "none"
          pre.style.display = "block"
        }
      }

      main().catch(err => {
        const e = document.getElementById("err")
        const l = document.getElementById("loading")
        if (l) l.style.display = "none"
        if (e){
          e.style.display = "block"
          e.textContent = String(err && err.stack ? err.stack : err)
        }
      })
    </script>
  </body>
</html>
