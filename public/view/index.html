<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>צפייה</title>
    <style>
      :root{
        --fs: 18px;
        --lh: 1.8;
        --readerMax: 980px;
        --pad: 18px;
        --drawerW: 340px;
      }

      body{
        font-family: system-ui, Arial;
        margin: 0;
        background: #fafafa;
      }

      body.book{
        --readerMax: 760px;
        --pad: 22px;
        --lh: 1.95;
      }

      .topbar{
        position: sticky;
        top: 0;
        z-index: 30;
        background: #fafafa;
        border-bottom: 1px solid #eee;
        padding: 10px 12px;
      }

      .row{
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .spacer{ flex: 1; }

      .btn{
        padding: 8px 12px;
        font-size: 14px;
        border: 1px solid #ddd;
        border-radius: 10px;
        background: #fff;
        cursor: pointer;
      }

      .btn:active{ transform: translateY(1px); }

      .pill{
        padding: 6px 10px;
        border: 1px solid #ddd;
        border-radius: 999px;
        background: #fff;
        font-size: 12px;
        color: #444;
      }

      .select{
        padding: 8px 10px;
        border: 1px solid #ddd;
        border-radius: 10px;
        background: #fff;
        font-size: 14px;
      }

      .meta{
        margin-top: 6px;
        font-size: 12px;
        color: #666;
        word-break: break-all;
      }

      .page{
        padding: 14px 12px 22px 12px;
      }

      .reader{
        max-width: var(--readerMax);
        margin: 0 auto;
      }

      .card{
        background: #fff;
        border: 1px solid #e5e5e5;
        border-radius: 12px;
        padding: var(--pad);
      }

      .loading{
        font-size: 14px;
        color: #666;
      }

      .content{
        font-size: var(--fs);
        line-height: var(--lh);
      }

      .content h1{ font-size: 1.55em; margin: 0 0 10px 0; }
      .content h2{ font-size: 1.25em; margin: 18px 0 8px 0; }
      .content h3{ font-size: 1.08em; margin: 14px 0 6px 0; }
      .content p { margin: 10px 0; }
      .content h1, .content h2, .content h3{ scroll-margin-top: 120px; }

      .pre{
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: calc(var(--fs) - 3px);
        line-height: 1.65;
        direction: rtl;
      }

      iframe{
        width: 100%;
        height: 80vh;
        border: 1px solid #e5e5e5;
        border-radius: 12px;
        background: #fff;
      }

      .err{
        color: #a00;
        font-size: 14px;
        white-space: pre-wrap;
        direction: ltr;
        text-align: left;
      }

      /* Drawer (תוכן עניינים) */
      .overlay{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.25);
        display: none;
        z-index: 40;
      }

      .drawer{
        position: fixed;
        top: 0;
        bottom: 0;
        right: 0;
        width: min(var(--drawerW), 92vw);
        background: #fff;
        border-left: 1px solid #e5e5e5;
        transform: translateX(110%);
        transition: transform 160ms ease;
        z-index: 50;
        display: flex;
        flex-direction: column;
      }

      .drawer.open{
        transform: translateX(0);
      }

      .overlay.open{
        display: block;
      }

      .drawerTop{
        padding: 10px 12px;
        border-bottom: 1px solid #eee;
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .drawerTitle{
        font-size: 14px;
        font-weight: 700;
      }

      .drawerBody{
        padding: 10px;
        overflow: auto;
      }

      .toc a{
        display: block;
        padding: 7px 10px;
        border-radius: 10px;
        text-decoration: none;
        color: #222;
        font-size: 13px;
      }

      .toc a:hover{
        background: #f3f3f3;
      }

      .toc .small{
        color: #666;
        font-size: 12px;
        padding: 6px 10px;
      }

      /* Printed TOC for PDF */
      .printToc { display: none; }
      @media print {
        .topbar, .overlay, .drawer { display: none !important; }
        body { background: #fff !important; }
        .page { padding: 0 !important; }
        .card { border: none !important; }
        .printToc { display: block !important; }
        .printToc h1 { margin: 0 0 12px 0; }
        .printToc ol { margin: 0; padding: 0 18px 0 0; }
        .printToc li { margin: 0 0 6px 0; }
        .printToc a { color: #000; text-decoration: underline; }
        .printBreak { page-break-after: always; }
      }
    </style>

    <script src="/vendor/jszip.min.js"></script>
  </head>

  <body>
    <div class="topbar">
      <div class="row">
        <button class="btn" onclick="history.back()">חזור</button>
        <button class="btn" id="btnRaw">פתח מקור (RAW)</button>
        <button class="btn" id="btnToc" style="display:none;">תוכן עניינים</button>

        <button class="btn" id="btnExportPdf" style="display:none;">ייצוא PDF</button>
        <button class="btn" id="btnExportDocx" style="display:none;">ייצוא DOCX</button>
        <button class="btn" id="btnExportEpub" style="display:none;">ייצוא EPUB</button>

        <span class="pill" id="fontLabel">גופן: —</span>
        <button class="btn" id="btnMinus" title="הקטן גופן">−</button>
        <button class="btn" id="btnPlus" title="הגדל גופן">+</button>

        <button class="btn" id="btnBook" title="מצב קריאה">עמוד ספר: כבוי</button>

        <span class="spacer"></span>

        <button class="btn" id="btnPrev" style="display:none;">◀ קודם</button>
        <button class="btn" id="btnNext" style="display:none;">הבא ▶</button>

        <select class="select" id="chapterSel" style="display:none;"></select>
        <select class="select" id="verseSel" style="display:none;"></select>
        <button class="btn" id="btnTop" style="display:none;">למעלה</button>
      </div>

      <div class="meta" id="meta"></div>
    </div>

    <div class="page">
      <div class="reader">
        <div class="card" id="card">
          <div class="loading" id="loading">טוען…</div>

          <div class="content" id="content" style="display:none;"></div>
          <pre class="pre" id="pre" style="display:none;"></pre>
          <div class="err" id="err" style="display:none;"></div>
          <iframe id="pdf" style="display:none;"></iframe>
        </div>
      </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <aside class="drawer" id="drawer">
      <div class="drawerTop">
        <div class="drawerTitle">תוכן עניינים</div>
        <span class="spacer"></span>
        <button class="btn" id="btnCloseToc">סגור</button>
      </div>
      <div class="drawerBody">
        <div class="toc">
          <div class="small" id="tocHint"></div>
          <div id="tocList"></div>
        </div>
      </div>
    </aside>

    <script>
      let currentPath = ""
      let currentSafeHtml = ""
      let currentPlainText = ""
      let currentTocItems = [] // [{id,label,level}]

      function encodePath(path){
        return String(path).split("/").filter(Boolean).map(encodeURIComponent).join("/")
      }

      function getParam(name){
        const u = new URL(location.href)
        return u.searchParams.get(name) || ""
      }

      function isPdf(path){
        return /\.pdf$/i.test(path || "")
      }

      function looksLikeHtml(text){
        const t = String(text || "")
        return /<\/?(h1|h2|h3|p|b|strong|div|span)\b/i.test(t)
      }

      function sanitizeHtml(html){
        const doc = new DOMParser().parseFromString(String(html || ""), "text/html")
        doc.querySelectorAll("script, style, iframe, object, embed, link").forEach(n => n.remove())

        doc.querySelectorAll("*").forEach(el => {
          for (const attr of Array.from(el.attributes)){
            const name = String(attr.name || "").toLowerCase()
            const val = String(attr.value || "")
            if (name.startsWith("on")) el.removeAttribute(attr.name)
            if (name === "href" && /^\s*javascript:/i.test(val)) el.removeAttribute(attr.name)
          }
          if (el.tagName === "A"){
            el.setAttribute("target","_blank")
            el.setAttribute("rel","noreferrer noopener")
          }
        })

        return doc.body.innerHTML
      }

      function clamp(n,a,b){ return Math.max(a, Math.min(b,n)) }

      function loadPrefs(){
        const fs = Number(localStorage.getItem("view_fs") || "18")
        const book = localStorage.getItem("view_book") === "1"
        return { fs: clamp(Number.isFinite(fs) ? fs : 18, 12, 34), book }
      }

      function savePrefs(p){
        localStorage.setItem("view_fs", String(p.fs))
        localStorage.setItem("view_book", p.book ? "1" : "0")
      }

      function applyPrefs(p){
        document.documentElement.style.setProperty("--fs", p.fs + "px")
        document.getElementById("fontLabel").textContent = "גופן: " + p.fs
        document.body.classList.toggle("book", !!p.book)
        document.getElementById("btnBook").textContent = "עמוד ספר: " + (p.book ? "פעיל" : "כבוי")
      }

      function slug(text){
        const t = String(text || "").trim()
        return t.replace(/\s+/g,"-").replace(/[^\u0590-\u05FFa-zA-Z0-9\-]/g,"").slice(0,80) || ("sec-" + Math.random().toString(16).slice(2))
      }

      function textOf(el){
        return String(el && el.textContent ? el.textContent : "").trim()
      }

      function scrollToId(id){
        const el = document.getElementById(id)
        if (!el) return
        el.scrollIntoView({ behavior: "smooth", block: "start" })
      }

      function openToc(){
        document.getElementById("overlay").classList.add("open")
        document.getElementById("drawer").classList.add("open")
      }

      function closeToc(){
        document.getElementById("overlay").classList.remove("open")
        document.getElementById("drawer").classList.remove("open")
      }

      function buildNav(){
        const content = document.getElementById("content")
        const nodes = Array.from(content.querySelectorAll("h1, h2, h3, h4"))
          .filter(n => textOf(n))

        if (nodes.length === 0) {
          currentTocItems = []
          return { items: [], steps: [] }
        }

        const items = nodes.map((n, idx) => {
          const level = Number(String(n.tagName).slice(1))
          if (!n.id) n.id = "h" + level + "-" + idx + "-" + slug(textOf(n))
          return { id: n.id, label: textOf(n), level }
        })

        currentTocItems = items

        document.getElementById("btnToc").style.display = "inline-block"
        document.getElementById("btnTop").style.display = "inline-block"

        const steps =
          items.filter(x => x.level === 3).length > 1 ? items.filter(x => x.level === 3) :
          items.filter(x => x.level === 2).length > 1 ? items.filter(x => x.level === 2) :
          items

        const btnPrev = document.getElementById("btnPrev")
        const btnNext = document.getElementById("btnNext")

        if (steps.length > 1) {
          btnPrev.style.display = "inline-block"
          btnNext.style.display = "inline-block"
        } else {
          btnPrev.style.display = "none"
          btnNext.style.display = "none"
        }

        document.getElementById("btnTop").onclick = () => window.scrollTo({ top: 0, behavior: "smooth" })

        const tocList = document.getElementById("tocList")
        const tocHint = document.getElementById("tocHint")
        tocList.innerHTML = ""

        const c1 = items.filter(x => x.level === 1).length
        const c2 = items.filter(x => x.level === 2).length
        const c3 = items.filter(x => x.level === 3).length
        const c4 = items.filter(x => x.level === 4).length
        tocHint.textContent =
          "H1: " + c1 + " | H2: " + c2 + " | H3: " + c3 + (c4 ? " | H4: " + c4 : "")

        items.forEach((it) => {
          const a = document.createElement("a")
          a.href = "#" + it.id
          a.textContent = it.label

          const indent = (Math.max(1, it.level) - 1) * 14
          a.style.paddingRight = (10 + indent) + "px"

          if (it.level === 1) a.style.fontWeight = "700"
          if (it.level >= 3) a.style.color = "#444"

          a.onclick = (e) => {
            e.preventDefault()
            closeToc()
            scrollToId(it.id)
          }

          tocList.appendChild(a)
        })

        let currentI = -1

        function setCurrentByScroll(){
          if (steps.length === 0) return
          const topY = window.scrollY + 140
          let best = -1

          for (let i = 0; i < steps.length; i++){
            const el = document.getElementById(steps[i].id)
            if (!el) continue
            const y = el.getBoundingClientRect().top + window.scrollY
            if (y <= topY) best = i
            else break
          }

          currentI = best
        }

        btnPrev.onclick = () => {
          if (steps.length === 0) return
          if (currentI <= 0) scrollToId(steps[0].id)
          else scrollToId(steps[currentI - 1].id)
        }

        btnNext.onclick = () => {
          if (steps.length === 0) return
          if (currentI < 0) scrollToId(steps[0].id)
          else if (currentI + 1 >= steps.length) scrollToId(steps[steps.length - 1].id)
          else scrollToId(steps[currentI + 1].id)
        }

        window.addEventListener("scroll", () => setCurrentByScroll(), { passive: true })
        setCurrentByScroll()

        return { items, steps }
      }

      function requireJSZip() {
        if (!window.JSZip) {
          alert("חסר JSZip. ודא ש-/vendor/jszip.min.js נטען תקין.")
          return false
        }
        return true
      }

      function xmlEscape(s) {
        return String(s || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll("\"", "&quot;")
          .replaceAll("'", "&apos;")
      }

      function downloadBlob(blob, filename) {
        const a = document.createElement("a")
        const url = URL.createObjectURL(blob)
        a.href = url
        a.download = filename
        document.body.appendChild(a)
        a.click()
        a.remove()
        setTimeout(() => URL.revokeObjectURL(url), 1500)
      }

      function baseNameFromPath(p) {
        const s = String(p || "").replaceAll("\\", "/")
        const parts = s.split("/")
        return (parts[parts.length - 1] || "book").trim()
      }

      function fileStem(name) {
        return String(name || "book").replace(/\.[a-z0-9]{2,6}$/i, "") || "book"
      }

      function getTitleFromDom() {
        const h1 = document.querySelector("#content h1")
        const t = h1 ? (h1.textContent || "").trim() : ""
        return t || "ספר"
      }

      // ---------- PDF (print) ----------
      // NOTE: internal # links often do NOT become clickable in Print-to-PDF.
      // We generate external links to your viewer: /view?path=...#id (these are usually clickable).
      function exportPdfWithPrintedToc() {
        const card = document.getElementById("card")
        const old = document.getElementById("printToc")
        if (old) old.remove()

        const items = Array.isArray(currentTocItems) ? currentTocItems : []
        const toc = document.createElement("div")
        toc.id = "printToc"
        toc.className = "printToc"

        const base = location.origin + "/view?path=" + encodeURIComponent(currentPath)

        let html = "<h1>תוכן עניינים</h1>"
        if (items.length) {
          html += "<ol>"
          items.forEach((it) => {
            const indent = (Math.max(1, it.level) - 1) * 14
            const url = base + "#" + encodeURIComponent(it.id)
            html += (
              "<li style=\"margin-right:" + indent + "px\">" +
                "<a href=\"" + url + "\">" + xmlEscape(it.label) + "</a>" +
              "</li>"
            )
          })
          html += "</ol>"
        } else {
          html += "<div style=\"color:#666\">(אין כותרות)</div>"
        }
        html += "<div class=\"printBreak\"></div>"

        toc.innerHTML = html
        card.insertBefore(toc, card.firstChild)

        const cleanup = () => {
          const x = document.getElementById("printToc")
          if (x) x.remove()
          window.removeEventListener("afterprint", cleanup)
        }
        window.addEventListener("afterprint", cleanup)

        window.print()
      }

      // ---------- DOCX ----------
      // Adds word/settings.xml + uses one-line TOC (hyperlinks separated by " | ")
      function docxXmlEscape(s){
        return xmlEscape(s)
      }

      function docxContentTypesXml() {
        return (
`<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
  <Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
</Types>`
        )
      }

      function docxRootRelsXml() {
        return (
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
  <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>`
        )
      }

      function docxDocumentRelsXml() {
        return (
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rIdStyles" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
  <Relationship Id="rIdSettings" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/>
</Relationships>`
        )
      }

      function docxSettingsXml() {
        // This is the piece that usually fixes "Word still LTR"
        return (
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:mirrorMargins/>
  <w:rtlGutter/>
  <w:themeFontLang w:val="en-US" w:bidi="he-IL"/>
  <w:bidi/>
</w:settings>`
        )
      }

      function docxStylesXml() {
        return (
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
    <w:name w:val="Normal"/>
    <w:qFormat/>
    <w:pPr><w:jc w:val="right"/><w:bidi/></w:pPr>
    <w:rPr><w:rtl/><w:lang w:val="he-IL" w:bidi="he-IL"/></w:rPr>
  </w:style>

  <w:style w:type="paragraph" w:styleId="Heading1">
    <w:name w:val="heading 1"/>
    <w:basedOn w:val="Normal"/>
    <w:next w:val="Normal"/>
    <w:qFormat/>
    <w:pPr><w:jc w:val="right"/><w:bidi/><w:spacing w:before="240" w:after="80"/></w:pPr>
    <w:rPr><w:rtl/><w:lang w:val="he-IL" w:bidi="he-IL"/><w:b/><w:sz w:val="48"/><w:szCs w:val="48"/></w:rPr>
  </w:style>

  <w:style w:type="paragraph" w:styleId="Heading2">
    <w:name w:val="heading 2"/>
    <w:basedOn w:val="Normal"/>
    <w:next w:val="Normal"/>
    <w:qFormat/>
    <w:pPr><w:jc w:val="right"/><w:bidi/><w:spacing w:before="200" w:after="70"/></w:pPr>
    <w:rPr><w:rtl/><w:lang w:val="he-IL" w:bidi="he-IL"/><w:b/><w:sz w:val="40"/><w:szCs w:val="40"/></w:rPr>
  </w:style>

  <w:style w:type="paragraph" w:styleId="Heading3">
    <w:name w:val="heading 3"/>
    <w:basedOn w:val="Normal"/>
    <w:next w:val="Normal"/>
    <w:qFormat/>
    <w:pPr><w:jc w:val="right"/><w:bidi/><w:spacing w:before="180" w:after="60"/></w:pPr>
    <w:rPr><w:rtl/><w:lang w:val="he-IL" w:bidi="he-IL"/><w:b/><w:sz w:val="34"/><w:szCs w:val="34"/></w:rPr>
  </w:style>

  <w:style w:type="paragraph" w:styleId="Heading4">
    <w:name w:val="heading 4"/>
    <w:basedOn w:val="Normal"/>
    <w:next w:val="Normal"/>
    <w:qFormat/>
    <w:pPr><w:jc w:val="right"/><w:bidi/><w:spacing w:before="160" w:after="50"/></w:pPr>
    <w:rPr><w:rtl/><w:lang w:val="he-IL" w:bidi="he-IL"/><w:b/><w:sz w:val="30"/><w:szCs w:val="30"/></w:rPr>
  </w:style>

  <w:style w:type="character" w:styleId="Hyperlink">
    <w:name w:val="Hyperlink"/>
    <w:uiPriority w:val="99"/>
    <w:unhideWhenUsed/>
    <w:rPr><w:color w:val="0000FF"/><w:u w:val="single"/><w:rtl/><w:lang w:val="he-IL" w:bidi="he-IL"/></w:rPr>
  </w:style>
</w:styles>`
        )
      }

      function docxCoreXml(title) {
        const nowIso = new Date().toISOString()
        return (
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:dcterms="http://purl.org/dc/terms/"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <dc:title>${docxXmlEscape(title)}</dc:title>
  <dc:language>he-IL</dc:language>
  <dcterms:created xsi:type="dcterms:W3CDTF">${nowIso}</dcterms:created>
</cp:coreProperties>`
        )
      }

      function docxAppXml() {
        return (
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"
  xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>otzaria-web</Application>
</Properties>`
        )
      }

      function normalizeSpacesKeepNewlines(s) {
        const x = String(s || "").replace(/\r\n/g, "\n")
        return x
          .replace(/[ \t]+\n/g, "\n")
          .replace(/\n[ \t]+/g, "\n")
      }

      function splitToParagraphs(text) {
        const t = normalizeSpacesKeepNewlines(text)
        const parts = t.split(/\n\s*\n+/g)
        return parts
          .map(p => p.replace(/\n+/g, " ").trim())
          .filter(p => p.length > 0)
      }

      function textFromNode(node) {
        let out = ""
        function walk(n) {
          if (!n) return
          if (n.nodeType === Node.TEXT_NODE) {
            out += n.nodeValue || ""
            return
          }
          if (n.nodeType === Node.ELEMENT_NODE) {
            const tag = (n.tagName || "").toUpperCase()
            if (tag === "BR") { out += " "; return }
            if (tag === "SCRIPT" || tag === "STYLE") return
            for (const c of Array.from(n.childNodes || [])) walk(c)
          }
        }
        walk(node)
        return out
      }

      function collectBlocksForDocx(root) {
        const blocks = []
        let buffer = ""

        function flush() {
          const paras = splitToParagraphs(buffer)
          paras.forEach((p) => blocks.push({ type: "p", text: p }))
          buffer = ""
        }

        function walk(node) {
          if (!node) return
          if (node.nodeType === Node.TEXT_NODE) {
            buffer += node.nodeValue || ""
            return
          }
          if (node.nodeType !== Node.ELEMENT_NODE) return

          const tag = (node.tagName || "").toUpperCase()

          if (tag === "H1" || tag === "H2" || tag === "H3" || tag === "H4") {
            flush()
            const lvl = Number(tag.slice(1))
            const t = (node.textContent || "").replace(/\s+/g, " ").trim()
            if (t) blocks.push({ type: "h", level: lvl, text: t })
            return
          }

          if (tag === "P" || tag === "BLOCKQUOTE" || tag === "PRE") {
            flush()
            const t = textFromNode(node).replace(/\s+/g, " ").trim()
            if (t) blocks.push({ type: "p", text: t })
            return
          }

          if (tag === "LI") {
            flush()
            const t = textFromNode(node).replace(/\s+/g, " ").trim()
            if (t) blocks.push({ type: "p", text: "• " + t })
            return
          }

          for (const c of Array.from(node.childNodes || [])) walk(c)
          if (tag === "DIV" || tag === "SECTION" || tag === "ARTICLE") buffer += "\n\n"
        }

        walk(root)
        flush()
        return blocks
      }

      function docxRun(text, opts) {
        const o = opts || {}
        const rtl = "<w:rtl/>"
        const lang = "<w:lang w:val=\"he-IL\" w:bidi=\"he-IL\"/>"
        const b = o.bold ? "<w:b/>" : ""
        const rStyle = o.rStyle ? "<w:rStyle w:val=\"" + o.rStyle + "\"/>" : ""
        return (
          "<w:r><w:rPr>" + rtl + lang + b + rStyle + "</w:rPr>" +
          "<w:t xml:space=\"preserve\">" + docxXmlEscape(text) + "</w:t></w:r>"
        )
      }

      function docxPPr(pStyle, spacingAfterTwips) {
        const jc = "<w:jc w:val=\"right\"/>"
        const bidi = "<w:bidi/>"
        const style = pStyle ? "<w:pStyle w:val=\"" + pStyle + "\"/>" : ""
        const spacing = "<w:spacing w:after=\"" + String(spacingAfterTwips ?? 80) + "\"/>"
        return "<w:pPr>" + style + jc + bidi + spacing + "</w:pPr>"
      }

      function docxPara(pStyle, text, bold) {
        return "<w:p>" + docxPPr(pStyle, 80) + docxRun(text, { bold: !!bold }) + "</w:p>"
      }

      function docxBookmarkStart(id, name) {
        return "<w:bookmarkStart w:id=\"" + id + "\" w:name=\"" + docxXmlEscape(name) + "\"/>"
      }

      function docxBookmarkEnd(id) {
        return "<w:bookmarkEnd w:id=\"" + id + "\"/>"
      }

      function docxHeadingWithBookmark(level, text, bmId, bmName) {
        const lvl = clamp(Number(level || 1), 1, 4)
        const style = "Heading" + lvl
        return (
          "<w:p>" +
            docxPPr(style, 80) +
            docxBookmarkStart(bmId, bmName) +
            docxRun(text, { bold: true }) +
            docxBookmarkEnd(bmId) +
          "</w:p>"
        )
      }

      function docxHyperlinkAnchor(anchorName, label) {
        return (
          "<w:hyperlink w:anchor=\"" + docxXmlEscape(anchorName) + "\" w:history=\"1\">" +
            docxRun(label, { rStyle: "Hyperlink" }) +
          "</w:hyperlink>"
        )
      }

      function docxPageBreak() {
        return "<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>"
      }

      function docxSectPr() {
        // rtlGutter inside section
        return "<w:sectPr><w:rtlGutter/></w:sectPr>"
      }

      function docxOneLineTocParagraph(tocEntries) {
        // One paragraph with many hyperlinks separated by " | "
        // It will wrap naturally in Word if too long.
        let p = "<w:p>" + docxPPr("Normal", 80)

        p += docxRun("תוכן עניינים: ", { bold: true })

        for (let i = 0; i < tocEntries.length; i++) {
          const e = tocEntries[i]
          const prefix = e.level > 1 ? ("»".repeat(Math.min(4, e.level - 1)) + " ") : ""
          p += docxHyperlinkAnchor(e.bmName, prefix + e.label)
          if (i !== tocEntries.length - 1) p += docxRun(" | ", {})
        }

        p += "</w:p>"
        return p
      }

      async function exportDocxFull() {
        if (!requireJSZip()) return

        const title = getTitleFromDom()
        const outName = fileStem(baseNameFromPath(currentPath)) + ".docx"

        const root = document.getElementById("content")
        let blocks = []

        if (root && root.style.display !== "none") {
          blocks = collectBlocksForDocx(root)
        } else {
          const paras = splitToParagraphs(currentPlainText || "")
          blocks = paras.map(p => ({ type: "p", text: p }))
          if (!blocks.length) blocks = [{ type:"p", text:"(ריק)" }]
        }

        let bmId = 1
        const tocEntries = []
        let bodyContent = ""

        blocks.forEach((b) => {
          if (b.type === "h") {
            const lvl = clamp(Number(b.level || 1), 1, 4)
            const bmName = "bm_" + bmId
            tocEntries.push({ label: b.text, level: lvl, bmName, bmId })
            bodyContent += docxHeadingWithBookmark(lvl, b.text, bmId, bmName)
            bmId++
          } else {
            bodyContent += docxPara("Normal", b.text, false)
          }
        })

        const tocPara = tocEntries.length
          ? docxOneLineTocParagraph(tocEntries)
          : docxPara("Normal", "תוכן עניינים: (אין כותרות)", true)

        const documentXml =
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    ${docxPara("Heading1", title, true)}
    ${tocPara}
    ${docxPageBreak()}
    ${bodyContent}
    ${docxSectPr()}
  </w:body>
</w:document>`

        const zip = new JSZip()
        zip.file("[Content_Types].xml", docxContentTypesXml())

        zip.folder("_rels").file(".rels", docxRootRelsXml())
        zip.folder("word").file("document.xml", documentXml)
        zip.folder("word").file("styles.xml", docxStylesXml())
        zip.folder("word").file("settings.xml", docxSettingsXml())
        zip.folder("word").folder("_rels").file("document.xml.rels", docxDocumentRelsXml())

        zip.folder("docProps").file("core.xml", docxCoreXml(title))
        zip.folder("docProps").file("app.xml", docxAppXml())

        const blob = await zip.generateAsync({
          type: "blob",
          mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        })

        downloadBlob(blob, outName)
      }

      // ---------- EPUB (Aquile) ----------
      // Split by H2 into multiple xhtml files => TOC navigation works reliably.
      function epubParse(html) {
        return new DOMParser().parseFromString(
          "<!doctype html><html><body>" + String(html || "") + "</body></html>",
          "text/html"
        )
      }

      function xhtmlFixVoidTags(s) {
        // very small fix for XHTML-ish output
        return String(s)
          .replace(/<br>/gi, "<br />")
          .replace(/<hr>/gi, "<hr />")
      }

      function epubSplitSections(doc) {
        const body = doc.body
        const nodes = Array.from(body.childNodes)

        // choose split tag: H2 if exists, else H1
        const hasH2 = Array.from(body.querySelectorAll("h2")).length > 0
        const splitTag = hasH2 ? "H2" : "H1"

        const sections = []
        let cur = []

        function pushSection() {
          if (cur.length) sections.push(cur)
          cur = []
        }

        nodes.forEach((n) => {
          if (n.nodeType === Node.ELEMENT_NODE && String(n.tagName).toUpperCase() === splitTag) {
            if (cur.length) pushSection()
            cur.push(n)
          } else {
            cur.push(n)
          }
        })

        pushSection()
        return { sections, splitTag }
      }

      function epubMakeSectionDoc(sectionNodes, globalHeadingCounter) {
        const d = document.implementation.createHTMLDocument("")
        const container = d.createElement("div")
        sectionNodes.forEach((n) => {
          container.appendChild(d.importNode(n, true))
        })

        // add explicit anchors sec-N before each heading
        const headings = Array.from(container.querySelectorAll("h1,h2,h3,h4"))
        const map = [] // {lvl, file, id, text}
        headings.forEach((h) => {
          const lvl = clamp(Number(String(h.tagName).slice(1)), 1, 4)
          const id = "sec-" + globalHeadingCounter.value++
          const a = d.createElement("a")
          a.setAttribute("id", id)
          h.parentNode.insertBefore(a, h)
          h.setAttribute("id", id)
          map.push({ lvl, id, text: (h.textContent || "").trim() || "כותרת" })
        })

        return { html: container.innerHTML, map }
      }

      function buildTreeFromFlat(items) {
        const roots = []
        const stack = []
        for (const it of items) {
          const node = { ...it, children: [] }
          while (stack.length && stack[stack.length - 1].lvl >= node.lvl) stack.pop()
          if (!stack.length) roots.push(node)
          else stack[stack.length - 1].children.push(node)
          stack.push(node)
        }
        return roots
      }

      function renderNavTree(nodes, hrefBuilder) {
        if (!nodes || !nodes.length) return "<ol></ol>"
        let out = "<ol>"
        for (const n of nodes) {
          out += "<li><a href=\"" + xmlEscape(hrefBuilder(n)) + "\">" + xmlEscape(n.text) + "</a>"
          if (n.children && n.children.length) out += renderNavTree(n.children, hrefBuilder)
          out += "</li>"
        }
        out += "</ol>"
        return out
      }

      function buildNcx(flatItems, uid, title) {
        let play = 1
        const navPoints = flatItems.slice(0, 1200).map((it) => {
          const pid = "navPoint-" + play
          const order = play++
          return (
            "<navPoint id=\"" + pid + "\" playOrder=\"" + order + "\">" +
              "<navLabel><text>" + xmlEscape(it.text) + "</text></navLabel>" +
              "<content src=\"" + xmlEscape(it.href) + "\"/>" +
            "</navPoint>"
          )
        }).join("")

        return (
`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN"
 "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd">
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
  <head>
    <meta name="dtb:uid" content="${xmlEscape(uid)}"/>
    <meta name="dtb:depth" content="4"/>
    <meta name="dtb:totalPageCount" content="0"/>
    <meta name="dtb:maxPageNumber" content="0"/>
  </head>
  <docTitle><text>${xmlEscape(title)}</text></docTitle>
  <navMap>
    ${navPoints}
  </navMap>
</ncx>`
        )
      }

      async function exportEpubFull() {
        if (!requireJSZip()) return

        const title = getTitleFromDom()
        const outName = fileStem(baseNameFromPath(currentPath)) + ".epub"

        let html = currentSafeHtml
        if (!html) {
          html = "<h1>" + xmlEscape(title) + "</h1><pre>" + xmlEscape(currentPlainText || "") + "</pre>"
        }

        const doc = epubParse(html)
        const split = epubSplitSections(doc)

        const uid = "uid-" + Math.random().toString(16).slice(2)
        const zip = new JSZip()

        zip.file("mimetype", "application/epub+zip", { compression: "STORE" })
        zip.folder("META-INF").file("container.xml",
`<?xml version="1.0"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`)

        const oebps = zip.folder("OEBPS")

        const css =
`body{ font-family:sans-serif; direction:rtl; line-height:1.85; font-size:1em; }
h1{ font-size:1.6em; margin:0 0 .6em 0; }
h2{ font-size:1.3em; margin:1.2em 0 .5em 0; }
h3{ font-size:1.15em; margin:1.0em 0 .4em 0; }
a[id]{ display:block; height:0; width:0; }
pre{ white-space:pre-wrap; }`
        oebps.file("style.css", css)

        const globalHeadingCounter = { value: 0 }

        const sectionFiles = []
        const allHeadingsFlat = [] // [{lvl,text,href}]
        const allHeadingsForTree = [] // [{lvl,text,href}] for tree nesting too

        for (let i = 0; i < split.sections.length; i++) {
          const nodes = split.sections[i]
          const sec = epubMakeSectionDoc(nodes, globalHeadingCounter)

          const filename = "section-" + String(i).padStart(3, "0") + ".xhtml"
          sectionFiles.push(filename)

          // Create XHTML for section
          const bodyInner = xhtmlFixVoidTags(sec.html)

          const xhtml =
`<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="he" lang="he" dir="rtl">
  <head>
    <meta charset="utf-8"/>
    <title>${xmlEscape(title)}</title>
    <link rel="stylesheet" type="text/css" href="style.css"/>
  </head>
  <body>
    ${bodyInner}
  </body>
</html>`
          oebps.file(filename, xhtml)

          // collect headings for TOC
          sec.map.forEach((h) => {
            const href = filename + "#" + h.id
            allHeadingsFlat.push({ lvl: h.lvl, text: h.text, href })
            allHeadingsForTree.push({ lvl: h.lvl, text: h.text, href })
          })
        }

        // Build NAV (nested)
        const tree = buildTreeFromFlat(allHeadingsForTree)
        const navOl = renderNavTree(tree, (n) => n.href)

        const navXhtml =
`<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="he" lang="he" dir="rtl">
  <head>
    <meta charset="utf-8"/>
    <title>תוכן עניינים</title>
  </head>
  <body>
    <nav epub:type="toc" id="toc" role="doc-toc" xmlns:epub="http://www.idpf.org/2007/ops">
      <h1>תוכן עניינים</h1>
      ${navOl}
    </nav>
  </body>
</html>`
        oebps.file("nav.xhtml", navXhtml)

        const ncx = buildNcx(allHeadingsFlat, uid, title)
        oebps.file("toc.ncx", ncx)

        // OPF manifest/spine
        let manifest = ""
        manifest += `<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>`
        manifest += `<item id="css" href="style.css" media-type="text/css"/>`
        manifest += `<item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>`
        sectionFiles.forEach((f, idx) => {
          manifest += `<item id="s${idx}" href="${f}" media-type="application/xhtml+xml"/>`
        })

        let spine = ""
        sectionFiles.forEach((_, idx) => {
          spine += `<itemref idref="s${idx}"/>`
        })

        const opf =
`<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="3.0" xml:lang="he">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:identifier id="BookId">${xmlEscape(uid)}</dc:identifier>
    <dc:title>${xmlEscape(title)}</dc:title>
    <dc:language>he</dc:language>
  </metadata>
  <manifest>
    ${manifest}
  </manifest>
  <spine toc="ncx">
    ${spine}
  </spine>
</package>`
        oebps.file("content.opf", opf)

        const blob = await zip.generateAsync({
          type: "blob",
          mimeType: "application/epub+zip"
        })

        downloadBlob(blob, outName)
      }

      function showExportButtonsForHtmlOrText() {
        const btnPdf = document.getElementById("btnExportPdf")
        const btnDocx = document.getElementById("btnExportDocx")
        const btnEpub = document.getElementById("btnExportEpub")

        btnPdf.style.display = "inline-block"
        btnPdf.textContent = "ייצוא PDF"
        btnPdf.onclick = () => exportPdfWithPrintedToc()

        btnDocx.style.display = "inline-block"
        btnDocx.textContent = "ייצוא DOCX"
        btnDocx.onclick = () => exportDocxFull()

        btnEpub.style.display = "inline-block"
        btnEpub.textContent = "ייצוא EPUB"
        btnEpub.onclick = () => exportEpubFull()
      }

      function showExportButtonsForPdf() {
        const btnPdf = document.getElementById("btnExportPdf")
        const btnDocx = document.getElementById("btnExportDocx")
        const btnEpub = document.getElementById("btnExportEpub")

        btnPdf.style.display = "inline-block"
        btnPdf.textContent = "הורד PDF"
        btnPdf.onclick = () => {
          const u = "/lib/" + encodePath(currentPath)
          window.open(u, "_blank", "noopener,noreferrer")
        }

        btnDocx.style.display = "none"
        btnEpub.style.display = "none"
      }

      async function main(){
        const prefs = loadPrefs()
        applyPrefs(prefs)

        document.getElementById("btnMinus").onclick = () => {
          const p = loadPrefs()
          p.fs = clamp(p.fs - 1, 12, 34)
          savePrefs(p)
          applyPrefs(p)
        }

        document.getElementById("btnPlus").onclick = () => {
          const p = loadPrefs()
          p.fs = clamp(p.fs + 1, 12, 34)
          savePrefs(p)
          applyPrefs(p)
        }

        document.getElementById("btnBook").onclick = () => {
          const p = loadPrefs()
          p.book = !p.book
          savePrefs(p)
          applyPrefs(p)
        }

        document.getElementById("btnToc").onclick = () => openToc()
        document.getElementById("btnCloseToc").onclick = () => closeToc()
        document.getElementById("overlay").onclick = () => closeToc()

        const path = getParam("path")
        const meta = document.getElementById("meta")
        const loading = document.getElementById("loading")
        const content = document.getElementById("content")
        const pre = document.getElementById("pre")
        const err = document.getElementById("err")
        const pdf = document.getElementById("pdf")
        const btnRaw = document.getElementById("btnRaw")

        if (!path){
          loading.style.display = "none"
          err.style.display = "block"
          err.textContent = "Missing ?path="
          return
        }

        currentPath = path
        currentSafeHtml = ""
        currentPlainText = ""
        currentTocItems = []

        meta.textContent = "path: " + path

        btnRaw.onclick = () => {
          const u = "/lib/" + encodePath(path)
          window.open(u, "_blank", "noopener,noreferrer")
        }

        if (isPdf(path)){
          loading.style.display = "none"
          pdf.style.display = "block"
          pdf.src = "/lib/" + encodePath(path)
          showExportButtonsForPdf()
          return
        }

        const url = "/lib/" + encodePath(path)
        const r = await fetch(url, { cache: "no-store" })
        if (!r.ok){
          loading.style.display = "none"
          err.style.display = "block"
          err.textContent = "Fetch failed: " + r.status + "\n" + url
          return
        }

        const text = await r.text()
        loading.style.display = "none"

        if (looksLikeHtml(text)){
          const safe = sanitizeHtml(text)
          if (safe && safe.trim().length > 10){
            content.style.display = "block"
            content.innerHTML = safe
            currentSafeHtml = safe
            buildNav()
            showExportButtonsForHtmlOrText()
          } else {
            pre.style.display = "block"
            pre.textContent = text
            currentPlainText = text
            currentTocItems = []
            showExportButtonsForHtmlOrText()
          }
        } else {
          pre.style.display = "block"
          pre.textContent = text
          currentPlainText = text
          currentTocItems = []
          showExportButtonsForHtmlOrText()
        }
      }

      main().catch((e) => {
        const loading = document.getElementById("loading")
        const err = document.getElementById("err")
        loading.style.display = "none"
        err.style.display = "block"
        err.textContent = String(e && e.message ? e.message : e)
      })
    </script>
  </body>
</html>
